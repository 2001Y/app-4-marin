# =============================================================================
# CloudKit schema v5 (2025-09-09)
# 前提:
# - プロフィールは Private DB (MyProfilePrivate) のみ。他人からは不可視。
# - 各ルーム = 1 共有ゾーン (pattern: room_* )。Room を親に全データを parent でぶら下げ。
# - ルーム一覧は Private DB の RoomListEntry（横断ソート/未読管理のためのローカルキャッシュ）。
# - 日付系フィールドは持たず、時刻は creationDate / modificationDate（システム）だけを使用。
# - Reaction/Attachment は Message の子。MessageAttachment.type は ['image','video'] に限定。
# - 参加/招待の権限は「誰でも可」。ownerUserRef や role/membership は持たない。
# - userId は CloudKit の「ユーザレコード（CKRecordTypeUserRecord）」の recordID.recordName を採用（端末/OSを跨いで不変）。
# - プロフィールに faceTimeID（メール or 電話番号）を追加。※Private専用。共有レコードには含めない。
#   - 用途例：アプリ内から facetime: / facetime-audio: URL スキームでFaceTimeを起動するための自己用メモ。
# =============================================================================

schema:
  version: 5
  notes: >
    最小・衝突少・運用容易を優先。横断一覧は Private の RoomListEntry でキャッシュ。
    並び・判定の時刻はすべて creationDate / modificationDate を参照。

databases:

  private:
    zones:
      - name: app.private
        record_types:

          - name: MyProfilePrivate
            fields:
              # userId は CKContainer.fetchUserRecordID() の戻り値 recordName を保存
              - { name: userId,        type: String, required: true }
              - { name: displayName,   type: String, required: true }
              - { name: avatarAsset,   type: Asset,  required: false }
              # FaceTime用の識別子（メール or 電話番号）。外部共有しない前提（Private専用）
              # ※ 必要に応じて facetime: / facetime-audio: URL スキームで起動に利用
              - { name: faceTimeID,    type: String, required: false }
            indexes:
              - { fields: [userId], order: asc }

          - name: RoomListEntry
            fields:
              - { name: sharedZoneOwnerName, type: String, required: true }  # 共有ゾーンの ownerName（例: "__CKUSER__…")
              - { name: sharedZoneName,      type: String, required: true }  # 例: "room_g32wf23f1"
              - { name: roomRecordName,      type: String, required: true }  # Room レコード名
              - { name: roomName,            type: String, required: true }
              - { name: roomImageAsset,      type: Asset,  required: false }
              - { name: lastMessageText,     type: String, required: false }
              - { name: lastMessageAt,       type: Date,   required: false }
              - { name: lastReadAt,          type: Date,   required: false }
              - { name: unreadCount,         type: Int64,  required: false } # キャッシュ値（最終的な真実は lastReadAt と Message.creationDate で算出）
            indexes:
              - { fields: [sharedZoneOwnerName, sharedZoneName, roomRecordName], order: asc }
              - { fields: [lastMessageAt], order: desc }
            # 共有DBを横断した即時集約は難しいため、一覧/未読は Private 側で冪等更新・キャッシュ
            # 既読は「チャットを開いた時点」で lastReadAt を即時更新（閉じるまでの間に届いた分は次回で補正）

  shared:
    zones:
      - pattern: "room_*"
        # 共有(Sharing)はカスタムゾーン前提。各ルーム=1ゾーンにより、同期・通知・権限をルーム単位で独立管理。

        record_types:

          # ----------------------------------------------------------
          # ルーム（共有ルート）
          # ※ UIで“作成者”を出す必要があれば、CKShare.owner を都度取得して表示する（Room フィールドでは保持しない）
          # ----------------------------------------------------------
          - name: Room
            fields:
              - { name: roomID,          type: String, required: true,  comment: "ゾーン名 (= shared zoneName) を冪等参照用に保持" }
              - { name: name,            type: String, required: true }
              - { name: shareURL,        type: String, required: false } # 共有リンクのキャッシュ（実体は CKShare.url）
              - { name: roomImageAsset,  type: Asset,  required: false,  comment: "部屋画像（くり抜き＝roomImageShape）」 }
              - { name: roomImageShape,  type: Int64,  required: false,  comment: "0..4 の安定形状。roomImageAsset のくり抜き形状" }
            # ここを親(parent)に、下位レコードを全てぶら下げる

          - name: RoomMember
            fields:
              # userId は参加者の userRecordID.recordName（共有の participants から得られる）
              - { name: userId,       type: String, required: true }
              - { name: displayName,  type: String, required: true }
              - { name: avatarAsset,  type: Asset,  required: false }
              - { name: faceTimeID,   type: String, required: false,  comment: "メンバーのFaceTime識別子（メール/電話）。UI発呼に利用" }
            parent: Room
            indexes:
              - { fields: [userId], order: asc }
            app_enforced_uniques:
              - [parent(Room), userId]  # 1ルームにつきユーザは一意（アプリ側で重複作成を防止）

          - name: Message
            fields:
              - { name: senderMemberRef, type: Reference(RoomMember), required: false, comment: "system の場合 null" }
              - { name: type,            type: String,                required: true,  enum: ['txt','attachment'] }
              - { name: text,            type: String,                required: false }
            # 添付は MessageAttachment に完全分離（Message 自体は CKAsset を持たない）
            parent: Room
            indexes:
              # 新着/未読計算で creationDate を使う想定。必要に応じて Console で Queryable を有効化
              - { fields: [creationDate], order: desc, queryable: true }
            # 並びの完全安定: recordName に ULID を採用し、クライアント側で (creationDate desc, recordName desc) で安定化

          - name: MessageAttachment
            fields:
              # 親削除カスケード用の通常参照（parent は deleteSelf 指定不可のため）
              - { name: messageRef, type: Reference(Message, action: 'deleteSelf'), required: true }
              - { name: type,   type: String, required: true, enum: ['image','video'] }
              - { name: asset,  type: Asset,  required: true }  # 大容量は Asset で保持（レコード本体は1MB制限）
            parent: Message

          - name: Reaction
            fields:
              - { name: messageRef, type: Reference(Message, action: 'deleteSelf'), required: true } # 親削除で自動消去
              - { name: memberRef, type: Reference(RoomMember), required: true }
              - { name: emoji,     type: String,                required: true }
            parent: Message
            app_enforced_uniques:
              - [parent(Message), memberRef, emoji]  # 同一メッセージに同一ユーザの同一絵文字は一意（アプリ側で担保）

          - name: Anniversary
            fields:
              - { name: title, type: String, required: true }
              - { name: date,  type: Date,   required: true }   # 次回計算はクライアント側（ローカル）
            parent: Room
            indexes:
              - { fields: [date], order: asc, queryable: true }

          - name: RTCSignal
            fields:
              - { name: fromMemberRef, type: Reference(RoomMember), required: true }
              - { name: toMemberRef,   type: Reference(RoomMember), required: true }
              - { name: callId,        type: String,                required: true,  comment: "同時通話識別子。多重通話/誤取込回避に使用" }
              - { name: type,          type: String,                required: true, enum: ['offer','answer','ice'] }
              - { name: payload,       type: String,                required: true }
              - { name: consumed,      type: Bool,                  required: true,  default: false }
              - { name: ttlSeconds,    type: Int64,                 required: false }
            parent: Room
            indexes:
              - { fields: [toMemberRef],   queryable: true }
              - { fields: [callId],        queryable: true }
              - { fields: [consumed],      queryable: true }
              - { fields: [creationDate],  order: desc, queryable: true }
            # 取込後は consumed=true。古い ICE/信号は ttlSeconds と creationDate を基準に定期削除（サーバ側TTLは無い）

subscriptions:
  # 共有DBでは CKQuerySubscription が使えないため、Database / RecordZone サブスクで差分取得をトリガ
  - name: room_zone_changes
    scope: "per-room-zone"
    type: RecordZoneSubscription
    notificationInfo:
      shouldSendContentAvailable: true
    # 運用: ルーム参加時に当該共有ゾーンへ購読を作成。退室時に削除。

  - name: shared_db_changes
    scope: "shared-database"
    type: DatabaseSubscription
    notificationInfo:
      shouldSendContentAvailable: true
    # 運用: 新規共有の受諾/ゾーン増減を検知→新ゾーンに RecordZoneSubscription を張る。

app_level_rules:
  - rule: "Room を親にすべての子レコードを配置（roomRefは持たない）"
  - rule: "時刻は creationDate / modificationDate のみを真実として使用（必要なら creationDate を Queryable に）"
  - rule: "RoomMember は削除可。過去の参照は UI で“名無し”表示を許容（senderMemberRef が切れても致命ではない）"
  - rule: "退室時は RTCSignal の自分宛購読を必ず破棄"
  - rule: "未読は RoomListEntry.lastReadAt と Message.creationDate で算出（unreadCount はキャッシュ）"
  - rule: "RoomListEntry.lastMessageText/At は新着Message通知受領時に冪等更新"
  - rule: "Message 削除時は子(Reaction/Attachment)の連鎖削除：deleteSelf 参照＋必要に応じ CKModifyRecordsOperation 同時実行"
  - rule: "RTCSignal は取込後 consumed=true、古いものは ttlSeconds / creationDate で定期削除（サーバTTLなし）"
  - rule: "recordName に ULID/UUID を採用し冪等保存（再送重複を回避）"
  - rule: "IDポリシー: userId は userRecordID.recordName（自分=fetchUserRecordID、相手=CKShare.participants 経由）"
  - rule: "faceTimeID は Private にのみ保持（共有データに含めない）"

# -----------------------------------------------------------------------------
# 運用メモ（実装tips）
# - “作成者”表示が必要になったら: その Room の CKShare.owner を都度取得して UI に表示（Room レコードには持たない）。
# - RoomList の未読: lastReadAt を入退室やフォア/バック切替時に更新。厳密個数が必要なら通知ごとに加算し、入室時に再計算で整合。
# - 添付: レコード本体は ~1MB 制限。画像/動画などは CKAsset で保持し、UIはプレビュー遅延に配慮。
# - 通知は合流/省略され得るため、push はあくまでトリガ。常に fetch*Changes で差分同期して最終整合を取る。
# - WebRTC: ICE はレコードが増えやすい。payload 間引き/バッチ化＋TTL/consumed で掃除。
# - FaceTime: faceTimeID（自分のメール/電話）を持っていれば、必要に応じて facetime: / facetime-audio: で外部アプリ起動が可能（相手のFaceTime連絡先は自動取得不可）。
# -----------------------------------------------------------------------------

examples:
  private:
    MyProfilePrivate:
      - userId: "usr_x23d2f2"          # = userRecordID.recordName
        displayName: "2001 Y"
        avatarAsset: null
        faceTimeID: "facetime@example.com"  # or "+819012345678"

    RoomListEntry:
      - sharedZoneOwnerName: "__CKUSER__abc123"
        sharedZoneName: "room_g32wf23f1"
        roomRecordName: "__ROOM____01JROOMA"
        roomName: "雑談"
        roomImageAsset: null
        lastMessageText: "それでOKです！"
        lastMessageAt: "2025-09-09T09:12:00Z"
        lastReadAt: "2025-09-09T09:10:00Z"
        unreadCount: 2

      - sharedZoneOwnerName: "__CKUSER__def456"
        sharedZoneName: "room_g78jk4l1"
        roomRecordName: "__ROOM____01JROOMB"
        roomName: "開発"
        roomImageAsset: null
        lastMessageText: "ビルド通った 🎉"
        lastMessageAt: "2025-09-09T08:40:00Z"
        lastReadAt: "2025-09-09T08:35:00Z"
        unreadCount: 1

  # ルーム「雑談」の共有ゾーン例（3人: 2001 Y / Alice / Bob）
  shared_room_g32wf23f1:
    Room:
      - roomID: "room_g32wf23f1"             # = shared zoneName
        name: "雑談"
        shareURL: "https://icloud.com/…"  # “作成者”は CKShare.owner を都度取得して表示
        roomImageShape: 2
        roomImageAsset: null

    RoomMember:
      - parent: "ref:Room(__ROOM____01JROOMA)"
        userId: "usr_x23d2f2"
        displayName: "2001 Y"
        avatarAsset: null
      - parent: "ref:Room(__ROOM____01JROOMA)"
        userId: "usr_alice"
        displayName: "Alice"
        avatarAsset: null
      - parent: "ref:Room(__ROOM____01JROOMA)"
        userId: "usr_bob"
        displayName: "Bob"
        avatarAsset: null

    Message:
      - parent: "ref:Room(__ROOM____01JROOMA)"
        senderMemberRef: "ref:RoomMember(__MEMBER__Y01)"   # 2001 Y
        type: "txt"
        text: "やっほー"

      - parent: "ref:Room(__ROOM____01JROOMA)"
        senderMemberRef: "ref:RoomMember(__MEMBER__A01)"   # Alice
        type: "txt"
        text: "今日のランチどうする？"

      - parent: "ref:Room(__ROOM____01JROOMA)"
        senderMemberRef: "ref:RoomMember(__MEMBER__B01)"   # Bob
        type: "attachment"
        text: null
        # 添付本体は下の MessageAttachment（このメッセージが親）

      - parent: "ref:Room(__ROOM____01JROOMA)"
        senderMemberRef: "ref:RoomMember(__MEMBER__Y01)"   # 2001 Y
        type: "txt"
        text: "それでOKです！"

    MessageAttachment:
      - parent: "ref:Message(__MSG_____ATT1)"   # 上の Bob の添付メッセージのレコード名を想定
        type: "image"
        asset: "(CKAsset)…"

    Reaction:
      - parent: "ref:Message(__MSG_____0001)"   # 1つ目のメッセージ（2001 Yの“やっほー”）に対して
        memberRef: "ref:RoomMember(__MEMBER__A01)"   # Alice
        emoji: "👍"
      - parent: "ref:Message(__MSG_____0002)"   # 2つ目（Aliceの“ランチどうする？”）
        memberRef: "ref:RoomMember(__MEMBER__Y01)"   # 2001 Y
        emoji: "❤️"
      - parent: "ref:Message(__MSG_____0004)"   # 4つ目（2001 Yの“それでOKです！”）
        memberRef: "ref:RoomMember(__MEMBER__B01)"   # Bob
        emoji: "👍"

    RTCSignal:
      - parent: "ref:Room(__ROOM____01JROOMA)"
        fromMemberRef: "ref:RoomMember(__MEMBER__A01)"  # Alice
        toMemberRef:   "ref:RoomMember(__MEMBER__B01)"  # Bob
        type: "offer"
        payload: '{"type":"offer","sdp":"..."}'
        consumed: false
        ttlSeconds: 600

      - parent: "ref:Room(__ROOM____01JROOMA)"
        fromMemberRef: "ref:RoomMember(__MEMBER__B01)"  # Bob
        toMemberRef:   "ref:RoomMember(__MEMBER__A01)"  # Alice
        type: "answer"
        payload: '{"type":"answer","sdp":"..."}'
        consumed: false
        ttlSeconds: 600

      - parent: "ref:Room(__ROOM____01JROOMA)"
        fromMemberRef: "ref:RoomMember(__MEMBER__Y01)"  # 2001 Y
        toMemberRef:   "ref:RoomMember(__MEMBER__A01)"  # Alice
        type: "ice"
        payload: '{"candidate":"candidate:0 1 udp 2122260223 192.0.2.1 54321 typ host","sdpMid":"0","sdpMLineIndex":0}'
        consumed: false
        ttlSeconds: 120

  # 別ルーム「開発」の共有ゾーン例（2人: 2001 Y / Alice）
  shared_room_g78jk4l1:
    Room:
      - roomID: "room_g78jk4l1"
        name: "開発"
        shareURL: "https://icloud.com/…"
        roomImageShape: 4
        roomImageAsset: null

    RoomMember:
      - parent: "ref:Room(__ROOM____01JROOMB)"
        userId: "usr_x23d2f2"
        displayName: "2001 Y"
        avatarAsset: null
      - parent: "ref:Room(__ROOM____01JROOMB)"
        userId: "usr_alice"
        displayName: "Alice"
        avatarAsset: null

    Message:
      - parent: "ref:Room(__ROOM____01JROOMB)"
        senderMemberRef: "ref:RoomMember(__MEMBER__A02)"   # Alice
        type: "txt"
        text: "ビルド通った 🎉"
