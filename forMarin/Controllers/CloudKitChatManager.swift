import Foundation
import CloudKit
import Combine
import SwiftUI

@MainActor
class CloudKitChatManager: ObservableObject {
    static let shared = CloudKitChatManager()
    
    private let container = CKContainer(identifier: "iCloud.forMarin-test")
    private let privateDB: CKDatabase
    private let sharedDB: CKDatabase
    
    @Published var currentUserID: String?
    @Published var isInitialized: Bool = false
    @Published var lastError: Error?
    @Published var hasPerformedReset: Bool = false
    
    // Schema creation flag
    private var isSyncDisabled: Bool = false
    
    // „Éó„É≠„Éï„Ç£„Éº„É´„Ç≠„É£„ÉÉ„Ç∑„É•ÔºàuserID -> (name, avatarData)Ôºâ
    private var profileCache: [String: (name: String?, avatarData: Data?)] = [:]
    
    
    private init() {
        self.privateDB = container.privateCloudDatabase
        self.sharedDB = container.sharedCloudDatabase
        
        setupSyncNotificationObservers()
        
        Task {
            await initialize()
        }
    }
    
    private func setupSyncNotificationObservers() {
        NotificationCenter.default.addObserver(
            forName: .disableMessageSync,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            Task { @MainActor in
                log("üõë Sync disabled for schema creation", category: "CloudKitChatManager")
                self?.isSyncDisabled = true
            }
        }
        
        NotificationCenter.default.addObserver(
            forName: .enableMessageSync,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            Task { @MainActor in
                log("‚úÖ Sync re-enabled after schema creation", category: "CloudKitChatManager")
                self?.isSyncDisabled = false
            }
        }
    }
    
    // MARK: - Log Dump Observer (Ë®∫Êñ≠Áî®)
    
    /// „É≠„Ç∞ÂèéÈõÜË¶ÅÊ±Ç„Å´Âøú„Åò„Å¶DBÁä∂ÊÖã„ÇíË©≥Á¥∞„Å´Âá∫Âäõ
    private func setupLogDumpObserver() {
        NotificationCenter.default.addObserver(
            forName: Notification.Name("RequestDatabaseDump"),
            object: nil,
            queue: .main
        ) { [weak self] notification in
            Task { @MainActor in
                let source = (notification.userInfo?["source"] as? String) ?? "unknown"
                log("üßæ Database dump requested (source: \(source))", category: "CloudKitChatManager")
                await self?.dumpDatabaseState(roomID: nil)
            }
        }
    }
    
    // MARK: - Initialization
    
    private func initialize() async {
        // Êóß„Éá„Éº„ÇøÊ§úÂá∫ÊôÇ„ÅÆËá™Âãï„É™„Çª„ÉÉ„ÉàÔºàÊú¨Áï™Áí∞Â¢É„Åß„ÇÇÊúâÂäπÔºâ
        do {
            try await resetIfLegacyDataDetected()
        } catch {
            log("‚ö†Ô∏è Legacy data reset failed (ignored): \(error)", category: "CloudKitChatManager")
        }
        
        await fetchCurrentUserID()
        
        // UserIDManager„ÅÆÈÄöÁü•„ÇíË≥ºË™≠
        setupUserIDNotifications()
        
        isInitialized = true
        log("Initialized successfully with userID: \(currentUserID ?? "unknown")", category: "CloudKitChatManager")
        
        // Ë®∫Êñ≠Áî®„ÉÄ„É≥„Éó„Ç™„Éñ„Ç∂„Éº„Éê„ÉºÁôªÈå≤
        setupLogDumpObserver()
        
        // ÈñãÁô∫Áí∞Â¢É„Åß„ÅÆ„Çπ„Ç≠„Éº„ÉûËá™Âãï‰ΩúÊàê„ÇíË©¶Ë°åÔºàÂàùÊúüÂåñÂæå„Å´Áã¨Á´ã„Åó„Å¶ÂÆüË°åÔºâ
        #if DEBUG
        log("üöÄ Starting DEBUG schema creation...", category: "CloudKitChatManager")
        Task {
            // „Çπ„Ç≠„Éº„Éû‰ΩúÊàê‰∏≠„ÅØ„É°„ÉÉ„Çª„Éº„Ç∏ÂêåÊúü„ÇíÂÅúÊ≠¢
            NotificationCenter.default.post(name: .disableMessageSync, object: nil)
            await createSchemaIfNeeded()
            // „Çπ„Ç≠„Éº„Éû‰ΩúÊàêÂÆå‰∫ÜÂæå„Å´„É°„ÉÉ„Çª„Éº„Ç∏ÂêåÊúü„ÇíÂÜçÈñã
            NotificationCenter.default.post(name: .enableMessageSync, object: nil)
        }
        #endif
    }
    
    #if DEBUG
    /// ÈñãÁô∫Áí∞Â¢É„Åß„Çπ„Ç≠„Éº„ÉûËá™Âãï‰ΩúÊàê„ÉªÂÜçÊßãÁØâ„ÇíË©¶Ë°å
    private func createSchemaIfNeeded() async {
        log("üîç Checking if schema creation is needed...", category: "CloudKitChatManager")
        
        // ÂÆüÈöõ„ÅÆCloudKit„Éá„Éº„Çø„Éô„Éº„ÇπÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
        let schemaIsValid = await validateExistingSchema()
        
        if schemaIsValid {
            log("‚úÖ Schema already exists and is valid, skipping creation", category: "CloudKitChatManager")
            return
        }
        
        log("üîß Schema validation failed or missing, starting comprehensive schema creation...", category: "CloudKitChatManager")
        
        // 1. Êó¢Â≠ò„Çπ„Ç≠„Éº„Éû„Çí„ÇØ„É™„Ç¢ÔºàÂïèÈ°å„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøÔºâ
        await clearDevelopmentSchema()
        
        // 2. ÂåÖÊã¨ÁöÑ„Å™„Çπ„Ç≠„Éº„Éû„Çí‰ΩúÊàê
        await createComprehensiveSchema()
        
        // 3. queryable „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂº∑Âà∂‰ΩúÊàê
        await forceCreateQueryableIndexes()
        
        // 4. „Çπ„Ç≠„Éº„ÉûÊ§úË®º„ÇíÂÆüË°å
        await validateCreatedSchema()
        
        log("‚úÖ Schema creation and validation completed successfully", category: "CloudKitChatManager")
        
        // „Çπ„Ç≠„Éº„Éû‰ΩúÊàêÂÆå‰∫Ü„ÇíÈÄöÁü•
        await MainActor.run {
            NotificationCenter.default.post(name: .cloudKitSchemaReady, object: nil)
        }
    }
    
    /// Êó¢Â≠ò„Çπ„Ç≠„Éº„Éû„ÅÆÊúâÂäπÊÄß„ÇíÂÆüÈöõ„ÅÆCloudKit„Éá„Éº„Çø„Éô„Éº„Çπ„ÅßÁ¢∫Ë™ç
    private func validateExistingSchema() async -> Bool {
        log("üîç Validating existing CloudKit schema...", category: "CloudKitChatManager")
        
        // 1. Âü∫Êú¨ÁöÑ„Å™„É¨„Ç≥„Éº„Éâ„Çø„Ç§„Éó„ÅÆ‰ΩúÊàêÂèØËÉΩÊÄß„Çí„ÉÜ„Çπ„Éà
        let testResult = await testBasicRecordCreation()
        if !testResult {
            log("‚ùå Basic record creation test failed", category: "CloudKitChatManager")
            return false
        }
        
        // 2. ÂøÖË¶Å„Å™„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÅÆÂ≠òÂú®Á¢∫Ë™ç
        let subscriptionsValid = await validateSubscriptions()
        if !subscriptionsValid {
            log("‚ùå Subscriptions validation failed", category: "CloudKitChatManager")
            return false
        }
        
        log("‚úÖ Existing schema is valid", category: "CloudKitChatManager")
        return true
    }
    
    /// Âü∫Êú¨ÁöÑ„Å™„É¨„Ç≥„Éº„Éâ‰ΩúÊàê„ÉÜ„Çπ„Éà
    private func testBasicRecordCreation() async -> Bool {
        log("üß™ Testing basic record creation...", category: "CloudKitChatManager")
        
        // „ÉÜ„Çπ„ÉàÁî®„ÅÆ‰∏ÄÊôÇÁöÑ„Å™„É¨„Ç≥„Éº„Éâ„Çí‰ΩúÊàê„Åó„Å¶„Åô„Åê„Å´ÂâäÈô§
        let testRecordTypes = ["CD_Message", "CD_ChatRoom", "CD_Profile"]
        
        for recordType in testRecordTypes {
            do {
                // „ÉÜ„Çπ„Éà„É¨„Ç≥„Éº„Éâ„Çí‰ΩúÊàê
                let testRecord = CKRecord(recordType: recordType)
                
                // ÊúÄÂ∞èÈôê„ÅÆ„Éï„Ç£„Éº„É´„ÉâË®≠ÂÆö
                switch recordType {
                case "CD_Message":
                    testRecord["roomID"] = "test" as CKRecordValue
                    testRecord["senderID"] = "test" as CKRecordValue
                    testRecord["body"] = "test" as CKRecordValue
                    testRecord["createdAt"] = Date() as CKRecordValue
                case "CD_ChatRoom":
                    testRecord["roomID"] = "test" as CKRecordValue
                    testRecord["participants"] = ["test"] as CKRecordValue
                    testRecord["createdAt"] = Date() as CKRecordValue
                case "CD_Profile":
                    testRecord["userID"] = "test" as CKRecordValue
                    testRecord["displayName"] = "test" as CKRecordValue
                    testRecord["updatedAt"] = Date() as CKRecordValue
                default:
                    break
                }
                
                // ‰ΩúÊàê„ÉÜ„Çπ„Éà
                let savedRecord = try await privateDB.save(testRecord)
                
                // „Åô„Åê„Å´ÂâäÈô§
                try await privateDB.deleteRecord(withID: savedRecord.recordID)
                
                log("‚úÖ \(recordType) creation test passed", category: "CloudKitChatManager")
                
            } catch {
                log("‚ùå \(recordType) creation test failed: \(error)", category: "CloudKitChatManager")
                return false
            }
        }
        
        return true
    }
    
    /// „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÅÆÂ≠òÂú®Á¢∫Ë™ç
    private func validateSubscriptions() async -> Bool {
        log("üîç Validating subscriptions...", category: "CloudKitChatManager")
        
        do {
            // Private DB subscriptions
            let privateSubscriptions = try await privateDB.allSubscriptions()
            let hasPrivateSubscription = privateSubscriptions.contains { subscription in
                subscription.subscriptionID == "private-database-changes"
            }
            
            // Shared DB subscriptions  
            let sharedSubscriptions = try await sharedDB.allSubscriptions()
            let hasSharedSubscription = sharedSubscriptions.contains { subscription in
                subscription.subscriptionID == "shared-database-changes"
            }
            
            let subscriptionsValid = hasPrivateSubscription && hasSharedSubscription
            
            if subscriptionsValid {
                log("‚úÖ Required subscriptions exist", category: "CloudKitChatManager")
            } else {
                log("‚ùå Missing required subscriptions", category: "CloudKitChatManager")
                log("Private subscription exists: \(hasPrivateSubscription)", category: "CloudKitChatManager")
                log("Shared subscription exists: \(hasSharedSubscription)", category: "CloudKitChatManager")
            }
            
            return subscriptionsValid
            
        } catch {
            log("‚ùå Subscription validation error: \(error)", category: "CloudKitChatManager")
            return false
        }
    }
    
    /// ÈñãÁô∫Áí∞Â¢É„ÅÆÊó¢Â≠ò„Éá„Éº„Çø„Çí„ÇØ„É™„Ç¢
    private func clearDevelopmentSchema() async {
        log("üóëÔ∏è Clearing existing development data...", category: "CloudKitChatManager")
        
        // 1. „Ç´„Çπ„Çø„É†„Çæ„Éº„É≥„Çí„ÇØ„É™„Ç¢„Åô„Çã„Åì„Å®„ÅßÈñ¢ÈÄ£„É¨„Ç≥„Éº„Éâ„ÇÇÂâäÈô§„Åï„Çå„Çã
        do {
            let zones = try await privateDB.allRecordZones()
            let customZones = zones.filter { !$0.zoneID.zoneName.hasPrefix("_") }
            
            if !customZones.isEmpty {
                let zoneIDs = customZones.map { $0.zoneID }
                _ = try await privateDB.modifyRecordZones(saving: [], deleting: zoneIDs)
                log("üóëÔ∏è Cleared \(zoneIDs.count) custom zones (and their records)", category: "CloudKitChatManager")
            } else {
                log("üì≠ No custom zones to clear", category: "CloudKitChatManager")
            }
        } catch {
            log("‚ö†Ô∏è Failed to clear custom zones: \(error)", category: "CloudKitChatManager")
        }
        
        // 2. Êó¢Â≠ò„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇÇ„ÇØ„É™„Ç¢
        do {
            try await removeAllSubscriptions()
            log("üóëÔ∏è Cleared all existing subscriptions", category: "CloudKitChatManager")
        } catch {
            log("‚ö†Ô∏è Failed to clear subscriptions: \(error)", category: "CloudKitChatManager")
        }
        
        // „Éá„Éï„Ç©„É´„Éà„Çæ„Éº„É≥„ÅÆ„É¨„Ç≥„Éº„Éâ„ÇÇÁ¢∫Ë™ç„Åó„Å¶„ÇØ„É™„Ç¢ÔºàÂÆâÂÖ®„Å™ÊñπÊ≥ïÔºâ
        let recordTypes = ["CD_Message", "CD_Anniversary", "CD_Profile", "CD_ChatRoom"]
        
        for recordType in recordTypes {
            do {
                // „Ç∑„É≥„Éó„É´„Å™„ÇØ„Ç®„É™„Åß„É¨„Ç≥„Éº„Éâ„ÇíÊ§úÁ¥¢
                let query = CKQuery(recordType: recordType, predicate: NSPredicate(value: true))
                let (results, _) = try await privateDB.records(matching: query, resultsLimit: 50)
                
                let recordIDs = results.compactMap { (recordID, result) -> CKRecord.ID? in
                    switch result {
                    case .success: return recordID
                    case .failure: return nil
                    }
                }
                
                if !recordIDs.isEmpty {
                    _ = try await privateDB.modifyRecords(saving: [], deleting: recordIDs)
                    log("üóëÔ∏è Cleared \(recordIDs.count) \(recordType) records from private DB", category: "CloudKitChatManager")
                } else {
                    log("üì≠ No \(recordType) records to clear", category: "CloudKitChatManager")
                }
            } catch {
                log("‚ö†Ô∏è Failed to clear \(recordType) from private DB: \(error)", category: "CloudKitChatManager")
                // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Å¶„ÇÇ„ÇØ„É™„Ç¢Âá¶ÁêÜ„ÅØÁ∂öË°å
            }
        }
        
        log("‚úÖ Development data clearing completed", category: "CloudKitChatManager")
    }
    
    /// ÂåÖÊã¨ÁöÑ„Å™„Çπ„Ç≠„Éº„Éû„Çí‰ΩúÊàê
    private func createComprehensiveSchema() async {
        log("üèóÔ∏è Creating comprehensive schema...", category: "CloudKitChatManager")
        
        // 1. ChatRoom„Çπ„Ç≠„Éº„ÉûÔºà„Éó„É©„Ç§„Éô„Éº„ÉàDBÔºâ
        await createChatRoomSchema()
        
        // 2. ÂÖ±ÊúâDB„Çπ„Ç≠„Éº„ÉûÔºà„Ç´„Çπ„Çø„É†„Çæ„Éº„É≥ÂÜÖÔºâ
        await createSharedDatabaseSchema()
        
        log("‚úÖ Comprehensive schema creation completed", category: "CloudKitChatManager")
    }
    
    /// ‰ΩúÊàê„Åï„Çå„Åü„Çπ„Ç≠„Éº„Éû„ÅÆÊ§úË®º
    private func validateCreatedSchema() async {
        log("üîç Starting schema validation...", category: "CloudKitChatManager")
        
        let validationResults = await performSchemaValidation()
        
        for (recordType, result) in validationResults {
            switch result {
            case .success(let fields):
                log("‚úÖ \(recordType) schema valid - fields: \(fields.joined(separator: ", "))", category: "CloudKitChatManager")
            case .failure(let error):
                log("‚ùå \(recordType) schema validation failed: \(error)", category: "CloudKitChatManager")
            }
        }
        
        log("üîç Schema validation completed", category: "CloudKitChatManager")
    }
    
    /// „Çπ„Ç≠„Éº„ÉûÊ§úË®º„ÇíÂÆüÈöõ„Å´ÂÆüË°å
    private func performSchemaValidation() async -> [String: Result<[String], Error>] {
        var results: [String: Result<[String], Error>] = [:]
        
        // ÂêÑ„É¨„Ç≥„Éº„Éâ„Çø„Ç§„Éó„ÇíÊ§úË®º„Åô„Çã„Åü„ÇÅ„ÅÆ‰∫àÊúü„Åï„Çå„Çã„Éï„Ç£„Éº„É´„Éâ
        let expectedFields: [String: [String]] = [
            "CD_Message": ["roomID", "senderID", "body", "createdAt", "reactionEmoji", "reactions"],
            "CD_ChatRoom": ["roomID", "participants", "createdAt", "createdBy", "lastMessageText", "lastMessageDate"],
            "CD_Anniversary": ["roomID", "title", "annivDate", "repeatType", "createdAt"],
            "CD_Profile": ["userID", "displayName", "updatedAt"]
        ]
        
        for (recordType, fields) in expectedFields {
            do {
                // „Éó„É©„Ç§„Éô„Éº„ÉàDB„Å®SharedDB„ÅÆ‰∏°Êñπ„ÅßÊ§úË®º
                let privateFields = try await validateRecordTypeInDatabase(recordType: recordType, expectedFields: fields, database: privateDB, databaseName: "Private")
                let sharedFields = try await validateRecordTypeInDatabase(recordType: recordType, expectedFields: fields, database: sharedDB, databaseName: "Shared")
                
                let allValidatedFields = Set(privateFields + sharedFields)
                results[recordType] = .success(Array(allValidatedFields))
                
            } catch {
                results[recordType] = .failure(error)
            }
        }
        
        return results
    }
    
    /// queryable „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂº∑Âà∂ÁöÑ„Å´‰ΩúÊàêÔºàDevelopmentÁí∞Â¢É„ÅÆ„ÅøÔºâ
    private func forceCreateQueryableIndexes() async {
        log("üîß Force creating queryable indexes for recordName fields...", category: "CloudKitChatManager")
        
        let recordTypes = ["CD_Message", "CD_ChatRoom", "CD_Profile", "CD_Anniversary"]
        
        for recordType in recordTypes {
            await forceQueryableForRecordType(recordType)
        }
        
        log("üîß Queryable index creation attempts completed", category: "CloudKitChatManager")
    }
    
    /// ÁâπÂÆö„ÅÆ„É¨„Ç≥„Éº„Éâ„Çø„Ç§„Éó„Åßqueryable„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂº∑Âà∂‰ΩúÊàê
    private func forceQueryableForRecordType(_ recordType: String) async {
        log("üîß Forcing queryable index for \(recordType)...", category: "CloudKitChatManager")
        
        do {
            // 1. „Çµ„É≥„Éó„É´„É¨„Ç≥„Éº„Éâ„Çí‰ΩúÊàê
            let tempRecordName = "temp-\(recordType)-\(UUID().uuidString)"
            let tempRecord = CKRecord(recordType: recordType, recordID: CKRecord.ID(recordName: tempRecordName))
            
            // „É¨„Ç≥„Éº„Éâ„Çø„Ç§„Éó„Å´Âøú„Åò„Å¶ÂøÖË¶Å„Éï„Ç£„Éº„É´„Éâ„ÇíËøΩÂä†
            switch recordType {
            case "CD_Message":
                tempRecord["roomID"] = "temp-room" as CKRecordValue
                tempRecord["senderID"] = "temp-sender" as CKRecordValue
                tempRecord["body"] = "temp-message" as CKRecordValue
                tempRecord["createdAt"] = Date() as CKRecordValue
            case "CD_ChatRoom":
                tempRecord["roomID"] = "temp-room" as CKRecordValue
                tempRecord["participants"] = ["temp-user"] as CKRecordValue
                tempRecord["createdAt"] = Date() as CKRecordValue
                tempRecord["createdBy"] = "temp-creator" as CKRecordValue
            case "CD_Profile":
                tempRecord["userID"] = "temp-user" as CKRecordValue
                tempRecord["displayName"] = "Temp User" as CKRecordValue
                tempRecord["updatedAt"] = Date() as CKRecordValue
            case "CD_Anniversary":
                tempRecord["roomID"] = "temp-room" as CKRecordValue
                tempRecord["title"] = "Temp Anniversary" as CKRecordValue
                tempRecord["annivDate"] = Date() as CKRecordValue
                tempRecord["createdAt"] = Date() as CKRecordValue
            default:
                log("‚ö†Ô∏è Unknown record type: \(recordType)", category: "CloudKitChatManager")
                return
            }
            
            // 2. „É¨„Ç≥„Éº„Éâ„Çí‰øùÂ≠ò
            let savedRecord = try await privateDB.save(tempRecord)
            log("‚úÖ Created temp record: \(savedRecord.recordID.recordName)", category: "CloudKitChatManager")
            
            // 3. recordName „Åß„ÇØ„Ç®„É™„ÇíÂÆüË°å„Åó„Å¶„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂº∑Âà∂‰ΩúÊàê
            try await attemptRecordNameQuery(recordType: recordType, recordName: tempRecordName)
            
            // 4. ‰∏ÄÊôÇ„É¨„Ç≥„Éº„Éâ„ÇíÂâäÈô§
            try await privateDB.deleteRecord(withID: savedRecord.recordID)
            log("üóëÔ∏è Cleaned up temp record: \(savedRecord.recordID.recordName)", category: "CloudKitChatManager")
            
        } catch {
            log("‚ö†Ô∏è Failed to force queryable for \(recordType): \(error)", category: "CloudKitChatManager")
            // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Å¶„ÇÇÁ∂öË°å
        }
    }
    
    /// recordName„ÇØ„Ç®„É™„ÇíË©¶Ë°å„Åó„Å¶„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ‰ΩúÊàê„Çí‰øÉ„Åô
    private func attemptRecordNameQuery(recordType: String, recordName: String) async throws {
        // Ë§áÊï∞„ÅÆ„ÇØ„Ç®„É™„Éë„Çø„Éº„É≥„ÇíË©¶Ë°å
        let queryPatterns: [(String, NSPredicate)] = [
            ("recordName exact match", NSPredicate(format: "recordName == %@", recordName)),
            ("recordName contains", NSPredicate(format: "recordName CONTAINS %@", String(recordName.prefix(10)))),
            ("recordName begins with", NSPredicate(format: "recordName BEGINSWITH %@", String(recordName.prefix(8))))
        ]
        
        for (patternName, predicate) in queryPatterns {
            do {
                let query = CKQuery(recordType: recordType, predicate: predicate)
                let (_, _) = try await privateDB.records(matching: query, resultsLimit: 1)
                
                log("‚úÖ \(recordType) \(patternName) query succeeded - CloudKit should now recognize recordName as queryable", category: "CloudKitChatManager")
                
                // ÊàêÂäü„Åó„Åü„ÇâÊ¨°„ÅÆ„Éë„Çø„Éº„É≥„ÇÇË©¶Ë°åÔºàË§áÊï∞„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Çø„Ç§„Éó„Çí‰ΩúÊàêÔºâ
                
            } catch let error as CKError {
                if error.code == .invalidArguments && error.localizedDescription.contains("not marked queryable") {
                    log("üìù \(recordType) \(patternName) failed with 'not queryable' - this is expected, trying to force index creation...", category: "CloudKitChatManager")
                    // „Åì„ÅÆ„Ç®„É©„Éº„ÅåÂá∫„Çã„Åì„Å®Ëá™‰Ωì„Åå„ÄÅCloudKit„Å´„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆÂøÖË¶ÅÊÄß„Çí‰ºù„Åà„Çã
                } else {
                    log("‚ö†Ô∏è \(recordType) \(patternName) query failed: \(error)", category: "CloudKitChatManager")
                }
            }
        }
    }
    
    /// ÁâπÂÆö„ÅÆ„Éá„Éº„Çø„Éô„Éº„Çπ„Åß„É¨„Ç≥„Éº„Éâ„Çø„Ç§„Éó„ÇíÊ§úË®º
    private func validateRecordTypeInDatabase(recordType: String, expectedFields: [String], database: CKDatabase, databaseName: String) async throws -> [String] {
        log("üîç Validating \(recordType) in \(databaseName) DB...", category: "CloudKitChatManager")
        
        // „Ç∑„É≥„Éó„É´„Å™„ÇØ„Ç®„É™„Çí‰ΩøÁî®Ôºà„ÇΩ„Éº„ÉàÊù°‰ª∂„Å™„ÅóÔºâ
        let query = CKQuery(recordType: recordType, predicate: NSPredicate(value: true))
        
        do {
            let (results, _) = try await database.records(matching: query, resultsLimit: 1)
            
            if let (_, result) = results.first {
                let record = try result.get()
                let availableFields = Array(record.allKeys())
                
                log("üìã \(recordType) in \(databaseName) DB has fields: \(availableFields.joined(separator: ", "))", category: "CloudKitChatManager")
                
                // ÊúüÂæÖ„Åï„Çå„Çã„Éï„Ç£„Éº„É´„Éâ„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                let missingFields = expectedFields.filter { !availableFields.contains($0) }
                if !missingFields.isEmpty {
                    log("‚ö†Ô∏è Missing fields in \(recordType) (\(databaseName) DB): \(missingFields.joined(separator: ", "))", category: "CloudKitChatManager")
                } else {
                    log("‚úÖ All expected fields found in \(recordType) (\(databaseName) DB)", category: "CloudKitChatManager")
                }
                
                return availableFields
            } else {
                log("üì≠ No records found for \(recordType) in \(databaseName) DB - schema may not be created yet", category: "CloudKitChatManager")
                return []
            }
        } catch {
            log("‚ùå Failed to validate \(recordType) in \(databaseName) DB: \(error)", category: "CloudKitChatManager")
            
            // „ÇØ„Ç®„É™„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„É¨„Ç≥„Éº„Éâ„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ„Å®‰ªÆÂÆö„Åó„Å¶Á©∫„ÅÆÈÖçÂàó„ÇíËøî„Åô
            if let ckError = error as? CKError, ckError.code == .invalidArguments {
                log("‚ö†Ô∏è Query not supported for \(recordType) in \(databaseName) DB - assuming no records exist", category: "CloudKitChatManager")
                return []
            }
            
            throw error
        }
    }
    
    /// ChatRoom„Çπ„Ç≠„Éº„Éû„Çí‰ΩúÊàêÔºà„Éó„É©„Ç§„Éô„Éº„ÉàDBÔºâ
    private func createChatRoomSchema() async {
        log("üìÅ Creating comprehensive ChatRoom schema in private DB...", category: "CloudKitChatManager")
        
        do {
            // „Ç´„Çπ„Çø„É†„Çæ„Éº„É≥„Çí‰ΩúÊàê
            let zoneID = CKRecordZone.ID(zoneName: "DevelopmentZone")
            let zone = CKRecordZone(zoneID: zoneID)
            let savedZone = try await privateDB.save(zone)
            log("‚úÖ Created development zone: \(savedZone.zoneID.zoneName)", category: "CloudKitChatManager")
            
            // ChatRoom„É¨„Ç≥„Éº„Éâ„Çí‰ΩúÊàêÔºà„Åô„Åπ„Å¶„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÇíÂê´„ÇÄÂåÖÊã¨ÁöÑ„Å™ÂÆöÁæ©Ôºâ
            log("üè† Creating CD_ChatRoom schema record...", category: "CloudKitChatManager")
            let roomRecord = CKRecord(recordType: "CD_ChatRoom", recordID: CKRecord.ID(recordName: "schema-chatroom", zoneID: zoneID))
            
            // „Åô„Åπ„Å¶„ÅÆ CD_ChatRoom „Éï„Ç£„Éº„É´„Éâ„ÇíÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö
            roomRecord["roomID"] = "schema-room-id" as CKRecordValue
            roomRecord["participants"] = ["user1", "user2"] as CKRecordValue
            roomRecord["createdAt"] = Date() as CKRecordValue
            roomRecord["createdBy"] = "schema-creator" as CKRecordValue
            roomRecord["lastMessageText"] = "Schema message" as CKRecordValue
            roomRecord["lastMessageDate"] = Date() as CKRecordValue
            
            let savedRoomRecord = try await privateDB.save(roomRecord)
            log("‚úÖ Created ChatRoom schema record with ID: \(savedRoomRecord.recordID.recordName)", category: "CloudKitChatManager")
            log("üìã ChatRoom record fields: \(savedRoomRecord.allKeys().joined(separator: ", "))", category: "CloudKitChatManager")
            
            // „Éó„É≠„Éï„Ç£„Éº„É´„É¨„Ç≥„Éº„Éâ„Çí‰ΩúÊàêÔºà„Éó„É©„Ç§„Éô„Éº„ÉàDBÔºâ
            log("üë§ Creating CD_Profile schema record in private DB...", category: "CloudKitChatManager")
            let profileRecord = CKRecord(recordType: "CD_Profile", recordID: CKRecord.ID(recordName: "schema-profile", zoneID: zoneID))
            
            // „Åô„Åπ„Å¶„ÅÆ CD_Profile „Éï„Ç£„Éº„É´„Éâ„ÇíÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö
            profileRecord["userID"] = "schema-user-id" as CKRecordValue
            profileRecord["displayName"] = "Schema User" as CKRecordValue
            profileRecord["updatedAt"] = Date() as CKRecordValue
            
            let savedProfileRecord = try await privateDB.save(profileRecord)
            log("‚úÖ Created Profile schema record in private DB with ID: \(savedProfileRecord.recordID.recordName)", category: "CloudKitChatManager")
            log("üìã Profile record fields: \(savedProfileRecord.allKeys().joined(separator: ", "))", category: "CloudKitChatManager")
            
            log("üìÅ ChatRoom schema creation in private DB completed successfully", category: "CloudKitChatManager")
            
        } catch {
            log("‚ùå Failed to create ChatRoom schema: \(error)", category: "CloudKitChatManager")
            if let ckError = error as? CKError {
                log("‚ùå CloudKit error details: \(ckError.localizedDescription)", category: "CloudKitChatManager")
                log("‚ùå Error code: \(ckError.code.rawValue)", category: "CloudKitChatManager")
                log("‚ùå Error user info: \(ckError.userInfo)", category: "CloudKitChatManager")
            }
        }
    }
    
    /// ÂÖ±ÊúâDB„Çπ„Ç≠„Éº„Éû„Çí‰ΩúÊàê
    private func createSharedDatabaseSchema() async {
        log("ü§ù Creating shared database schema...", category: "CloudKitChatManager")
        
        // ÂÖ±ÊúâDB„ÅÆ„Çπ„Ç≠„Éº„Éû„ÅØÂÆüÈöõ„ÅÆÂÖ±Êúâ„É¨„Ç≥„Éº„Éâ„Çí‰ΩúÊàê„Åô„Çã„Åì„Å®„Åß‰ΩúÊàê„Åï„Çå„Çã
        do {
            // 1. „Éó„É©„Ç§„Éô„Éº„ÉàDB„Åß„ÉÅ„É£„ÉÉ„Éà„É´„Éº„É†„Çí‰ΩúÊàêÔºàÂÆüÈöõ„ÅÆ„ÉÅ„É£„ÉÉ„Éà‰ΩúÊàê„Å®Âêå„Åò„Éó„É≠„Çª„ÇπÔºâ
            let zoneID = CKRecordZone.ID(zoneName: "SchemaZone-\(UUID().uuidString.prefix(8))")
            let zone = CKRecordZone(zoneID: zoneID)
            _ = try await privateDB.save(zone)
            log("‚úÖ Created schema zone: \(zoneID.zoneName)", category: "CloudKitChatManager")
            
            // 2. „ÉÅ„É£„ÉÉ„Éà„É´„Éº„É†„É¨„Ç≥„Éº„Éâ„Çí‰ΩúÊàê
            let roomRecord = CKRecord(recordType: "CD_ChatRoom", recordID: CKRecord.ID(recordName: "shared-schema-room", zoneID: zoneID))
            roomRecord["roomID"] = "shared-schema-room-id" as CKRecordValue
            roomRecord["participants"] = ["schema-user1", "schema-user2"] as CKRecordValue
            roomRecord["createdAt"] = Date() as CKRecordValue
            roomRecord["createdBy"] = "schema-creator" as CKRecordValue
            roomRecord["lastMessageText"] = "Schema message" as CKRecordValue
            roomRecord["lastMessageDate"] = Date() as CKRecordValue
            
            // 3. CKShare„Çí‰ΩúÊàê
            let share = CKShare(rootRecord: roomRecord)
            share.publicPermission = .readWrite
            share[CKShare.SystemFieldKey.title] = "Schema Chat Room"
            
            // 4. rootRecord„Å®Share„ÇíÂêåÊôÇ„Å´‰øùÂ≠ò
            let recordsToSave = [roomRecord, share]
            let saveResults = try await privateDB.modifyRecords(saving: recordsToSave, deleting: [])
            
            guard let savedRoomRecord = try saveResults.saveResults[roomRecord.recordID]?.get() as? CKRecord,
                  let savedShare = try saveResults.saveResults[share.recordID]?.get() as? CKShare else {
                throw CloudKitChatError.recordSaveFailed
            }
            
            log("‚úÖ Created shared room with share", category: "CloudKitChatManager")
            log("üìã Share URL: \(savedShare.url?.absoluteString ?? "No URL")", category: "CloudKitChatManager")
            
            // 5. ÂÖ±Êúâ„Çæ„Éº„É≥„Å´Â≠ê„É¨„Ç≥„Éº„Éâ„Çí‰ΩúÊàêÔºà„Åì„Çå„ÅßÂÖ±ÊúâDB„Åß„ÅÆ„Çπ„Ç≠„Éº„Éû„Åå‰ΩúÊàê„Åï„Çå„ÇãÔºâ
            await createSharedRecords(in: savedRoomRecord.recordID.zoneID, parentRecord: savedRoomRecord)
            
        } catch {
            log("‚ùå Failed to create shared database schema: \(error)", category: "CloudKitChatManager")
            if let ckError = error as? CKError {
                log("‚ùå CloudKit error details: \(ckError.localizedDescription)", category: "CloudKitChatManager")
                log("‚ùå Error code: \(ckError.code.rawValue)", category: "CloudKitChatManager")
            }
        }
    }
    
    /// ÂÖ±Êúâ„É¨„Ç≥„Éº„ÉâÔºà„É°„ÉÉ„Çª„Éº„Ç∏„ÄÅË®òÂøµÊó•„ÄÅ„Éó„É≠„Éï„Ç£„Éº„É´Ôºâ„Çí‰ΩúÊàê
    private func createSharedRecords(in zoneID: CKRecordZone.ID, parentRecord: CKRecord) async {
        log("üèóÔ∏è Creating shared records in private DB shared zone...", category: "CloudKitChatManager")
        
        // ÈáçË¶ÅÔºöÂÖ±Êúâ„É¨„Ç≥„Éº„Éâ„ÅØ„Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰ΩúÊàê„Åó„ÄÅroomID/userID„Éï„Ç£„Éº„É´„Éâ„ÅßÈñ¢ÈÄ£‰ªò„Åë
        
        // „É°„ÉÉ„Çª„Éº„Ç∏„É¨„Ç≥„Éº„Éâ - „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰ΩúÊàê
        do {
            log("üìù Creating CD_Message schema record in shared zone...", category: "CloudKitChatManager")
            let messageRecord = CKRecord(recordType: "CD_Message", 
                                       recordID: CKRecord.ID(zoneID: zoneID))
            
            // „Åô„Åπ„Å¶„ÅÆ CD_Message „Éï„Ç£„Éº„É´„Éâ„ÇíÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö
            messageRecord["roomID"] = "shared-schema-room-id" as CKRecordValue
            messageRecord["senderID"] = "schema-sender" as CKRecordValue
            messageRecord["body"] = "Schema test message" as CKRecordValue
            messageRecord["createdAt"] = Date() as CKRecordValue
            messageRecord["reactionEmoji"] = "" as CKRecordValue
            messageRecord["reactions"] = "" as CKRecordValue
            
            // CloudKitÊ®ôÊ∫ñÔºöË¶™„É¨„Ç≥„Éº„ÉâÂèÇÁÖß„ÇíË®≠ÂÆöÔºàÂêå„Åò„Çæ„Éº„É≥ÂÜÖÔºâ
            messageRecord.setParent(parentRecord)
            
            // Ê§úÁ¥¢Áî®Ë£úÂä©„Å®„Åó„Å¶roomID„Éï„Ç£„Éº„É´„Éâ„ÇÇ‰ΩµÁî®
            
            // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰øùÂ≠òÔºàCKShare„Å´„Çà„ÇäËá™ÂãïÁöÑ„Å´ÂÖ±Êúâ„Åï„Çå„ÇãÔºâ
            let savedMessageRecord = try await privateDB.save(messageRecord)
            log("‚úÖ Created Message schema record with ID: \(savedMessageRecord.recordID.recordName)", category: "CloudKitChatManager")
            log("üìã Message record fields: \(savedMessageRecord.allKeys().joined(separator: ", "))", category: "CloudKitChatManager")
            
        } catch {
            log("‚ùå Failed to create Message schema: \(error)", category: "CloudKitChatManager")
            if let ckError = error as? CKError {
                log("‚ùå CloudKit error details: \(ckError.localizedDescription)", category: "CloudKitChatManager")
                log("‚ùå Error code: \(ckError.code.rawValue)", category: "CloudKitChatManager")
            }
        }
        
        // Ë®òÂøµÊó•„É¨„Ç≥„Éº„Éâ - „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰ΩúÊàê
        do {
            log("üéâ Creating CD_Anniversary schema record in shared zone...", category: "CloudKitChatManager")
            let anniversaryRecord = CKRecord(recordType: "CD_Anniversary", 
                                           recordID: CKRecord.ID(zoneID: zoneID))
            
            // „Åô„Åπ„Å¶„ÅÆ CD_Anniversary „Éï„Ç£„Éº„É´„Éâ„ÇíÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö
            anniversaryRecord["roomID"] = "shared-schema-room-id" as CKRecordValue
            anniversaryRecord["title"] = "Schema Anniversary" as CKRecordValue
            anniversaryRecord["annivDate"] = Date() as CKRecordValue
            anniversaryRecord["repeatType"] = "none" as CKRecordValue
            anniversaryRecord["createdAt"] = Date() as CKRecordValue
            
            // CloudKitÊ®ôÊ∫ñÔºöË¶™„É¨„Ç≥„Éº„ÉâÂèÇÁÖß„ÇíË®≠ÂÆöÔºàÂêå„Åò„Çæ„Éº„É≥ÂÜÖÔºâ
            anniversaryRecord.setParent(parentRecord)
            
            // Ê§úÁ¥¢Áî®Ë£úÂä©„Å®„Åó„Å¶roomID„Éï„Ç£„Éº„É´„Éâ„ÇÇ‰ΩµÁî®
            
            // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰øùÂ≠òÔºàCKShare„Å´„Çà„ÇäËá™ÂãïÁöÑ„Å´ÂÖ±Êúâ„Åï„Çå„ÇãÔºâ
            let savedAnniversaryRecord = try await privateDB.save(anniversaryRecord)
            log("‚úÖ Created Anniversary schema record with ID: \(savedAnniversaryRecord.recordID.recordName)", category: "CloudKitChatManager")
            log("üìã Anniversary record fields: \(savedAnniversaryRecord.allKeys().joined(separator: ", "))", category: "CloudKitChatManager")
            
        } catch {
            log("‚ùå Failed to create Anniversary schema: \(error)", category: "CloudKitChatManager")
            if let ckError = error as? CKError {
                log("‚ùå CloudKit error details: \(ckError.localizedDescription)", category: "CloudKitChatManager")
            }
        }
        
        // „Éó„É≠„Éï„Ç£„Éº„É´„É¨„Ç≥„Éº„Éâ - „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰ΩúÊàê
        do {
            log("üë§ Creating CD_Profile schema record in shared zone...", category: "CloudKitChatManager")
            let profileRecord = CKRecord(recordType: "CD_Profile", 
                                      recordID: CKRecord.ID(zoneID: zoneID))
            
            // „Åô„Åπ„Å¶„ÅÆ CD_Profile „Éï„Ç£„Éº„É´„Éâ„ÇíÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö
            profileRecord["userID"] = "schema-shared-user" as CKRecordValue
            profileRecord["displayName"] = "Schema Shared User" as CKRecordValue
            profileRecord["updatedAt"] = Date() as CKRecordValue
            
            // CloudKitÊ®ôÊ∫ñÔºöË¶™„É¨„Ç≥„Éº„ÉâÂèÇÁÖß„ÇíË®≠ÂÆöÔºàÂêå„Åò„Çæ„Éº„É≥ÂÜÖÔºâ
            profileRecord.setParent(parentRecord)
            
            // Ê§úÁ¥¢Áî®Ë£úÂä©„Å®„Åó„Å¶userID„Éï„Ç£„Éº„É´„Éâ„ÇÇ‰ΩµÁî®
            
            // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰øùÂ≠òÔºàCKShare„Å´„Çà„ÇäËá™ÂãïÁöÑ„Å´ÂÖ±Êúâ„Åï„Çå„ÇãÔºâ
            let savedProfileRecord = try await privateDB.save(profileRecord)
            log("‚úÖ Created Profile schema record in shared zone with ID: \(savedProfileRecord.recordID.recordName)", category: "CloudKitChatManager")
            log("üìã Profile record fields: \(savedProfileRecord.allKeys().joined(separator: ", "))", category: "CloudKitChatManager")
            
        } catch {
            log("‚ùå Failed to create Profile schema in shared zone: \(error)", category: "CloudKitChatManager")
            if let ckError = error as? CKError {
                log("‚ùå CloudKit error details: \(ckError.localizedDescription)", category: "CloudKitChatManager")
            }
        }
        
        log("üèóÔ∏è Shared records creation completed", category: "CloudKitChatManager")
        
        // Â∞ë„ÅóÂæÖ„Å£„Å¶„Åã„ÇâÂÖ±ÊúâDB„ÅÆ„Çπ„Ç≠„Éº„Éû„Åå‰ΩúÊàê„Åï„Çå„Åü„Åì„Å®„ÇíÁ¢∫Ë™ç
        try? await Task.sleep(nanoseconds: 2_000_000_000) // 2ÁßíÂæÖÊ©ü
        await verifySharedDatabaseSchema()
    }
    
    /// „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Åß„ÅÆ„Çπ„Ç≠„Éº„Éû‰ΩúÊàê„ÇíÁ¢∫Ë™ç
    private func verifySharedDatabaseSchema() async {
        log("üîç Verifying shared zone schema in private DB...", category: "CloudKitChatManager")
        
        let recordTypes = ["CD_Message", "CD_Anniversary", "CD_Profile"]
        
        for recordType in recordTypes {
            do {
                // „Éó„É©„Ç§„Éô„Éº„ÉàDB„Åß„É¨„Ç≥„Éº„Éâ„ÇíÊ§úÁ¥¢„Åó„Å¶„Çπ„Ç≠„Éº„Éû„ÅåÂà©Áî®ÂèØËÉΩ„ÅãÁ¢∫Ë™ç
                let query = CKQuery(recordType: recordType, predicate: NSPredicate(value: true))
                let (results, _) = try await privateDB.records(matching: query, resultsLimit: 1)
                
                if let (_, result) = results.first {
                    let record = try result.get()
                    log("‚úÖ Private DB shared zone schema verified for \(recordType)", category: "CloudKitChatManager")
                    log("üìã \(recordType) fields: \(record.allKeys().joined(separator: ", "))", category: "CloudKitChatManager")
                } else {
                    log("‚ö†Ô∏è No \(recordType) records found in private DB shared zone yet", category: "CloudKitChatManager")
                }
            } catch {
                log("‚ùå \(recordType) schema verification failed: \(error)", category: "CloudKitChatManager")
                if let ckError = error as? CKError {
                    log("‚ùå CloudKit error details: \(ckError.localizedDescription)", category: "CloudKitChatManager")
                }
            }
        }
    }
    #endif
    
    private func fetchCurrentUserID() async {
        // UserIDManager„Åã„ÇâÁµ±‰∏Ä„Åï„Çå„Åü„É¶„Éº„Ç∂„ÉºID„ÇíÂèñÂæó
        currentUserID = await UserIDManager.shared.getCurrentUserIDAsync()
        
        if let userID = currentUserID {
            log("Using unified UserID: \(userID)", category: "CloudKitChatManager")
        } else {
            log("Failed to get unified UserID from UserIDManager", category: "CloudKitChatManager")
            lastError = CloudKitChatError.userNotAuthenticated
        }
    }
    
    // MARK: - Schema Management
    
    /// CloudKit„Çπ„Ç≠„Éº„Éû„ÇíÊâãÂãï„ÅßÂÜçÊßãÁØâÔºàÊú¨Áï™Áí∞Â¢É„Åß„ÇÇÂà©Áî®ÂèØËÉΩÔºâ
    func rebuildCloudKitSchema(force: Bool = false) async throws {
        log("üîÑ Manual CloudKit schema rebuild requested...", category: "CloudKitChatManager")
        
        // Êú¨Áï™Áí∞Â¢É„Åß„ÅØÂÆâÂÖ®„ÉÅ„Çß„ÉÉ„ÇØ„ÇíÂÆüË°å
        if !force {
            let isProduction = await checkIsProductionEnvironment()
            if isProduction {
                log("‚ö†Ô∏è Production environment detected. Use force=true for emergency reset.", category: "CloudKitChatManager")
                throw CloudKitChatError.productionResetBlocked
            }
        }
        
        // „Çπ„Ç≠„Éº„ÉûÂÜçÊßãÁØâ„ÇíÂÆüË°å
        await createSchemaIfNeeded()
        
        log("‚úÖ Manual schema rebuild completed", category: "CloudKitChatManager")
    }
    
    /// ÈñãÁô∫Áî®: CloudKit„Çπ„Ç≠„Éº„Éû„ÇíÂº∑Âà∂ÁöÑ„Å´„É™„Çª„ÉÉ„Éà„ÉªÂÜçÊßãÁØâ
    func forceSchemaReset() async {
        log("üö® Force schema reset requested...", category: "CloudKitChatManager")
        
        do {
            try await rebuildCloudKitSchema(force: true)
            log("‚úÖ Force schema reset completed successfully", category: "CloudKitChatManager")
        } catch {
            log("‚ùå Force schema reset failed: \(error)", category: "CloudKitChatManager")
        }
    }
    
    /// CloudKit„Éá„Éº„Çø„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÁ¢∫Ë™ç
    func getCloudKitSchemaStatus() async -> [String: Any] {
        var status: [String: Any] = [:]
        
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆ„É¨„Ç≥„Éº„ÉâÊï∞„ÇíÁ¢∫Ë™ç
        let recordTypes = ["CD_ChatRoom", "CD_Profile"]
        for recordType in recordTypes {
            do {
                let query = CKQuery(recordType: recordType, predicate: NSPredicate(value: true))
                let (results, _) = try await privateDB.records(matching: query)
                status["\(recordType)_private_count"] = results.count
            } catch {
                status["\(recordType)_private_error"] = error.localizedDescription
            }
        }
        
        // „Ç´„Çπ„Çø„É†„Çæ„Éº„É≥Êï∞„ÇíÁ¢∫Ë™ç
        do {
            let zones = try await privateDB.allRecordZones()
            let customZones = zones.filter { !$0.zoneID.zoneName.hasPrefix("_") }
            status["custom_zones_count"] = customZones.count
            status["custom_zones"] = customZones.map { $0.zoneID.zoneName }
        } catch {
            status["zones_error"] = error.localizedDescription
        }
        
        return status
    }
    
    
    // MARK: - Room Management
    
    /// ÂÖ±Êúâ„ÉÅ„É£„ÉÉ„Éà„É´„Éº„É†„Çí‰ΩúÊàê„Åó„ÄÅCKShare„ÇíÁîüÊàê
    func createSharedChatRoom(with remoteUserID: String) async throws -> (roomRecord: CKRecord, share: CKShare) {
        guard let myID = currentUserID else {
            throw CloudKitChatError.userNotAuthenticated
        }
        
        let roomID = ChatRoom.generateDeterministicRoomID(myID: myID, remoteID: remoteUserID)
        log("üèóÔ∏è Creating shared chat room with roomID: \(roomID)", category: "CloudKitChatManager")
        
        // Áµ±‰∏ÄÂÖ±Êúâ„Çæ„Éº„É≥„Çí‰ΩøÁî®ÔºàÂÖ®„Éá„Éê„Ç§„ÇπÂÖ±ÈÄöÔºâ
        let sharedZoneID = CKRecordZone.ID(zoneName: "SharedRooms")
        let sharedZone = CKRecordZone(zoneID: sharedZoneID)
        
        do {
            _ = try await privateDB.save(sharedZone)
            log("üèóÔ∏è Created unified shared zone: SharedRooms", category: "CloudKitChatManager")
        } catch let error as CKError where error.code == .serverRecordChanged {
            // „Çæ„Éº„É≥„ÅåÊó¢„Å´Â≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
            log("üèóÔ∏è Unified shared zone already exists: SharedRooms", category: "CloudKitChatManager")
        }
        
        // Êó¢Â≠ò„ÅÆ„É¨„Ç≥„Éº„Éâ„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàÁµ±‰∏Ä„Çæ„Éº„É≥ÂÜÖ„ÅßÔºâ
        let recordID = CKRecord.ID(recordName: roomID, zoneID: sharedZoneID)
        
        do {
            // Êó¢Â≠ò„ÅÆ„É¨„Ç≥„Éº„Éâ„ÇíÂèñÂæó„ÇíË©¶Ë°åÔºà‰∫ãÂâç„Éï„Çß„ÉÉ„ÉÅÔºâ
            let existingRecord = try await privateDB.record(for: recordID)
            log("üîç Found existing chat room: \(roomID)", category: "CloudKitChatManager")
            
            // Êó¢Â≠ò„ÅÆshare„ÇíÊ§úÁ¥¢
            let shareQuery = CKQuery(recordType: "cloudkit.share", predicate: NSPredicate(format: "rootRecord == %@", existingRecord.recordID))
            let (shareResults, _) = try await privateDB.records(matching: shareQuery)
            
            if let existingShare = shareResults.first?.1 as? CKShare {
                log("üîç Found existing share for room: \(roomID)", category: "CloudKitChatManager")
                return (roomRecord: existingRecord, share: existingShare)
            }
        } catch let error as CKError where error.code == .unknownItem {
            // „É¨„Ç≥„Éº„Éâ„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÊñ∞Ë¶è‰ΩúÊàê„Å∏ÈÄ≤„ÇÄ
            log("üîç No existing chat room found, creating new one", category: "CloudKitChatManager")
        } catch {
            log("‚ùå Error checking existing room: \(error)", category: "CloudKitChatManager")
            throw error
        }
        
        // Êñ∞„Åó„ÅÑ„É¨„Ç≥„Éº„Éâ„Çí‰ΩúÊàê
        let roomRecord = CKRecord(recordType: "CD_ChatRoom", recordID: recordID)
        roomRecord["roomID"] = roomID
        roomRecord["participants"] = [myID, remoteUserID] as [String]
        roomRecord["createdAt"] = Date()
        roomRecord["createdBy"] = myID
        
        // CKShare„Çí‰ΩúÊàê
        let share = CKShare(rootRecord: roomRecord)
        share[CKShare.SystemFieldKey.title] = "Chat with \(remoteUserID)"
        share.publicPermission = .readWrite
        
        // ‰∏°Êñπ„ÅÆ„É¨„Ç≥„Éº„Éâ„ÇíÂéüÂ≠êÁöÑ„Å´‰øùÂ≠òÔºàÁ´∂ÂêàÂá¶ÁêÜ‰ªò„ÅçÔºâ
        let recordsToSave = [roomRecord, share]
        
        do {
            let saveResults = try await privateDB.modifyRecords(saving: recordsToSave, deleting: [])
            
            guard let savedRoomRecord = try saveResults.saveResults[roomRecord.recordID]?.get() as? CKRecord,
                  let savedShare = try saveResults.saveResults[share.recordID]?.get() as? CKShare else {
                throw CloudKitChatError.recordSaveFailed
            }
            
            log("‚úÖ Successfully saved new room and share: \(roomID)", category: "CloudKitChatManager")
            if let url = savedShare.url?.absoluteString {
                log("üîó Share URL created for room \(roomID): \(url)", category: "CloudKitChatManager")
            } else {
                log("‚ö†Ô∏è Share URL is nil (room: \(roomID))", category: "CloudKitChatManager")
            }
            
            // „ÉÅ„É£„ÉÉ„Éà‰ΩúÊàêÊôÇ„Å´„Éó„É≠„Éï„Ç£„Éº„É´„ÇíÂêåÊúü
            Task {
                do {
                    try await syncProfileToChat(roomID: roomID)
                    log("Profile synced to new chat room: \(roomID)", category: "CloudKitChatManager")
                } catch {
                    log("Failed to sync profile to new room: \(error)", category: "CloudKitChatManager")
                }
            }
            
            return (roomRecord: savedRoomRecord, share: savedShare)
            
        } catch let error as CKError where error.code == .serverRecordChanged {
            // Á´∂ÂêàÁô∫ÁîüÔºö„Çµ„Éº„Éê„Éº‰∏ä„ÅÆ„É¨„Ç≥„Éº„Éâ„ÇíÊé°Áî®
            log("‚ö†Ô∏è Server record changed during save - adopting existing record: \(roomID)", category: "CloudKitChatManager")
            
            // Êó¢Â≠ò„É¨„Ç≥„Éº„Éâ„ÇíÂÜçÂèñÂæó
            if let existingRecord = try? await privateDB.record(for: recordID) {
                let shareQuery = CKQuery(recordType: "cloudkit.share", predicate: NSPredicate(format: "rootRecord == %@", existingRecord.recordID))
                let (shareResults, _) = try await privateDB.records(matching: shareQuery)
                
                if let existingShare = shareResults.first?.1 as? CKShare {
                    log("‚úÖ Adopted existing room after conflict: \(roomID)", category: "CloudKitChatManager")
                    return (roomRecord: existingRecord, share: existingShare)
                }
            }
            
            throw error
        }
    }
    
    /// roomID„Å´ÂØæÂøú„Åô„Çã„É´„Éº„É†„É¨„Ç≥„Éº„Éâ„ÇíÂèñÂæóÔºàÁµ±‰∏ÄÂÖ±Êúâ„Çæ„Éº„É≥„Åã„ÇâÔºâ
    func getRoomRecord(for roomID: String) async -> CKRecord? {
        log("üîç FRESH getRoomRecord for roomID: \(roomID)", category: "CloudKitChatManager")
        
        // Áµ±‰∏ÄÂÖ±Êúâ„Çæ„Éº„É≥„Åã„ÇâÊ§úÁ¥¢Ôºà„Ç≠„É£„ÉÉ„Ç∑„É•„Å™„Åó„ÉªÊØéÂõûÊñ∞Ë¶èÂèñÂæóÔºâ
        let sharedZoneID = CKRecordZone.ID(zoneName: "SharedRooms")
        let recordID = CKRecord.ID(recordName: roomID, zoneID: sharedZoneID)
        
        do {
            // Áõ¥Êé•„É¨„Ç≥„Éº„ÉâID„ÅßÂèñÂæó„ÇíË©¶Ë°å
            let record = try await privateDB.record(for: recordID)
            log("üîç Found room record in SharedRooms zone: \(roomID)", category: "CloudKitChatManager")
            
            // „ÉÅ„É£„ÉÉ„ÉàÂèÇÂä†ÊôÇ„Å´„Éó„É≠„Éï„Ç£„Éº„É´„ÇíÂêåÊúü
            Task {
                do {
                    try await syncProfileToChat(roomID: roomID)
                    log("Profile synced to existing chat room: \(roomID)", category: "CloudKitChatManager")
                } catch {
                    log("Failed to sync profile to existing room: \(error)", category: "CloudKitChatManager")
                }
            }
            
            return record
        } catch let error as CKError where error.code == .zoneNotFound {
            log("‚ö†Ô∏è SharedRooms zone not found - room may not exist yet: \(roomID)", category: "CloudKitChatManager")
            // Ë®∫Êñ≠: „Çæ„Éº„É≥‰∏ÄË¶ß„ÇíÂá∫Âäõ
            await dumpZoneList()
            return nil
        } catch let error as CKError where error.code == .unknownItem {
            log("üîç Room record not found in SharedRooms zone: \(roomID)", category: "CloudKitChatManager")
            // Ë®∫Êñ≠: „Çæ„Éº„É≥‰∏ÄË¶ß„ÇíÂá∫Âäõ
            await dumpZoneList()
            return nil
        } catch {
            log("‚ùå Error fetching room record: \(error)", category: "CloudKitChatManager")
            return nil
        }
    }
    
    
    // MARK: - Role Management
    
    /// roomID„Å´ÂØæ„Åó„Å¶„Åì„ÅÆ„É¶„Éº„Ç∂„Éº„Åå„Ç™„Éº„Éä„Éº„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆöÔºà„Ç≠„É£„ÉÉ„Ç∑„É•„Å™„Åó„ÉªÊØéÂõûÊñ∞Ë¶èÂèñÂæóÔºâ
    func isOwnerOfRoom(_ roomID: String) async -> Bool {
        log("üîç FRESH ownership check started for roomID: \(roomID)", category: "CloudKitChatManager")
        
        // ÁèæÂú®„ÅÆ„É¶„Éº„Ç∂„ÉºID„ÇíÊØéÂõûÊñ∞Ë¶èÂèñÂæó
        guard let currentUserID = currentUserID else {
            log("‚ùå Cannot determine ownership: currentUserID is nil", category: "CloudKitChatManager")
            return false
        }
        
        log("üîç Current user ID: \(currentUserID)", category: "CloudKitChatManager")
        
        // „É´„Éº„É†„É¨„Ç≥„Éº„Éâ„ÇíÊØéÂõûÊñ∞Ë¶èÂèñÂæó
        guard let roomRecord = await getRoomRecord(for: roomID) else {
            log("‚ùå Cannot determine ownership: roomRecord not found for \(roomID)", category: "CloudKitChatManager")
            return false
        }
        
        // createdBy„Éï„Ç£„Éº„É´„Éâ„ÅßÂà§ÂÆö
        let createdBy = roomRecord["createdBy"] as? String
        log("üîç Room createdBy: \(createdBy ?? "nil")", category: "CloudKitChatManager")
        
        let isOwner = createdBy == currentUserID
        
        log("üîç FRESH ownership determined for roomID: \(roomID) -> isOwner: \(isOwner) (createdBy: \(createdBy ?? "nil"), currentUser: \(currentUserID))", category: "CloudKitChatManager")
        
        return isOwner
    }
    
    /// ÁèæÂú®„ÅÆ„É¶„Éº„Ç∂„Éº„Åå„Ç™„Éº„Éä„Éº„ÅÆ„É´„Éº„É†‰∏ÄË¶ß„ÇíÂèñÂæóÔºà„Ç≠„É£„ÉÉ„Ç∑„É•„Å™„Åó„ÉªÊØéÂõûÊñ∞Ë¶èÂèñÂæóÔºâ
    func getOwnedRooms() async -> [String] {
        guard let currentUserID = currentUserID else {
            log("‚ùå Cannot get owned rooms: currentUserID is nil", category: "CloudKitChatManager")
            return []
        }
        
        var ownedRooms: [String] = []
        
        log("üîç FRESH check for owned rooms by user: \(currentUserID)", category: "CloudKitChatManager")
        
        // Áµ±‰∏ÄÂÖ±Êúâ„Çæ„Éº„É≥„Åã„ÇâÂÖ®„Å¶„ÅÆ„É´„Éº„É†„É¨„Ç≥„Éº„Éâ„ÇíÊ§úÁ¥¢
        let sharedZoneID = CKRecordZone.ID(zoneName: "SharedRooms")
        let predicate = NSPredicate(format: "createdBy == %@", currentUserID)
        let query = CKQuery(recordType: "CD_ChatRoom", predicate: predicate)
        
        do {
            let (results, _) = try await privateDB.records(matching: query, inZoneWith: sharedZoneID)
            
            for (_, result) in results {
                if let roomRecord = try? result.get(),
                   let roomID = roomRecord["roomID"] as? String {
                    ownedRooms.append(roomID)
                    log("üîç Found owned room: \(roomID)", category: "CloudKitChatManager")
                }
            }
        } catch {
            log("‚ùå Error fetching owned rooms: \(error)", category: "CloudKitChatManager")
        }
        
        log("üîç Total owned rooms: \(ownedRooms.count)", category: "CloudKitChatManager")
        return ownedRooms
    }
    
    /// ÂèÇÂä†„Åó„Å¶„ÅÑ„Çã„É´„Éº„É†‰∏ÄË¶ß„ÇíÂèñÂæóÔºà„Ç™„Éº„Éä„Éº„Åß„ÅØ„Å™„ÅÑ„ÇÇ„ÅÆ„Éª„Ç≠„É£„ÉÉ„Ç∑„É•„Å™„ÅóÔºâ
    func getParticipatingRooms() async -> [String] {
        guard let currentUserID = currentUserID else {
            log("‚ùå Cannot get participating rooms: currentUserID is nil", category: "CloudKitChatManager")
            return []
        }
        
        var participatingRooms: [String] = []
        
        log("üîç FRESH check for participating rooms by user: \(currentUserID)", category: "CloudKitChatManager")
        
        // Áµ±‰∏ÄÂÖ±Êúâ„Çæ„Éº„É≥„Åã„ÇâÂèÇÂä†„Åó„Å¶„ÅÑ„Çã„É´„Éº„É†„É¨„Ç≥„Éº„Éâ„ÇíÊ§úÁ¥¢
        let sharedZoneID = CKRecordZone.ID(zoneName: "SharedRooms")
        let predicate = NSPredicate(format: "participants CONTAINS %@", currentUserID)
        let query = CKQuery(recordType: "CD_ChatRoom", predicate: predicate)
        
        do {
            let (results, _) = try await privateDB.records(matching: query, inZoneWith: sharedZoneID)
            
            for (_, result) in results {
                if let roomRecord = try? result.get(),
                   let roomID = roomRecord["roomID"] as? String,
                   let createdBy = roomRecord["createdBy"] as? String,
                   createdBy != currentUserID {
                    participatingRooms.append(roomID)
                    log("üîç Found participating room: \(roomID) (createdBy: \(createdBy))", category: "CloudKitChatManager")
                }
            }
        } catch {
            log("‚ùå Error fetching participating rooms: \(error)", category: "CloudKitChatManager")
        }
        
        log("üîç Total participating rooms: \(participatingRooms.count)", category: "CloudKitChatManager")
        return participatingRooms
    }
    
    // MARK: - Message Operations
    
    /// „É°„ÉÉ„Çª„Éº„Ç∏„Çí„Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´ÈÄÅ‰ø°
    func sendMessage(_ message: Message, to roomRecord: CKRecord) async throws -> String {
        guard !isSyncDisabled else {
            log("üõë Sync is disabled, skipping message send", category: "CloudKitChatManager")
            throw CloudKitChatError.schemaCreationInProgress
        }
        
        // roomRecord„Å®Âêå„Åò„Çæ„Éº„É≥„Çí‰ΩøÁî®ÔºàÂÖ±Êúâ„Çæ„Éº„É≥Ôºâ
        let messageRecord = CKRecord(recordType: "CD_Message", 
                                   recordID: CKRecord.ID(zoneID: roomRecord.recordID.zoneID))
        
        messageRecord["roomID"] = message.roomID
        messageRecord["senderID"] = message.senderID
        messageRecord["body"] = message.body ?? ""
        messageRecord["createdAt"] = message.createdAt
        messageRecord["reactionEmoji"] = message.reactionEmoji ?? ""
        
        // CloudKitÊ®ôÊ∫ñÔºöË¶™„É¨„Ç≥„Éº„ÉâÂèÇÁÖß„ÇíË®≠ÂÆöÔºàÂêå„Åò„Çæ„Éº„É≥ÂÜÖÔºâ
        messageRecord.setParent(roomRecord)
        
        // Ê§úÁ¥¢Áî®Ë£úÂä©„Å®„Åó„Å¶roomID„Éï„Ç£„Éº„É´„Éâ„ÇÇ‰ΩµÁî®
        
        // „Ç¢„Çª„ÉÉ„ÉàÔºàÁîªÂÉè„ÉªÂãïÁîªÔºâ„Åå„ÅÇ„ÇãÂ†¥Âêà
        if let assetPath = message.assetPath, FileManager.default.fileExists(atPath: assetPath) {
            let assetURL = URL(fileURLWithPath: assetPath)
            messageRecord["asset"] = CKAsset(fileURL: assetURL)
        }
        
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰øùÂ≠òÔºàCKShare„Å´„Çà„ÇäËá™ÂãïÁöÑ„Å´ÂÖ±Êúâ„Åï„Çå„ÇãÔºâ
        let savedRecord = try await privateDB.save(messageRecord)
        log("Message sent to private DB shared zone: \(savedRecord.recordID.recordName)", category: "CloudKitChatManager")
        
        return savedRecord.recordID.recordName
    }
    
    /// „É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÊõ¥Êñ∞
    func updateMessage(recordName: String, newBody: String) async throws {
        let recordID = CKRecord.ID(recordName: recordName)
        let record = try await privateDB.record(for: recordID)
        record["body"] = newBody
        _ = try await privateDB.save(record)
        log("Message updated: \(recordName)", category: "CloudKitChatManager")
    }
    
    /// „É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂâäÈô§
    func deleteMessage(recordName: String) async throws {
        let recordID = CKRecord.ID(recordName: recordName)
        _ = try await privateDB.deleteRecord(withID: recordID)
        log("Message deleted: \(recordName)", category: "CloudKitChatManager")
    }
    
    // MARK: - Subscription Management
    
    /// „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥Áî®„ÅÆ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇíË®≠ÂÆö
    func setupSharedDatabaseSubscriptions() async throws {
        // „Éó„É©„Ç§„Éô„Éº„ÉàDBÂÖ®‰Ωì„ÅÆÂ§âÊõ¥„ÇíÁõ£Ë¶ñÔºàÂÖ±Êúâ„Çæ„Éº„É≥„ÅÆ„É¨„Ç≥„Éº„Éâ„ÇÇÂê´„ÇÄÔºâ
        let privateSubscription = CKDatabaseSubscription(subscriptionID: "private-database-changes")
        
        let privateNotificationInfo = CKSubscription.NotificationInfo()
        privateNotificationInfo.shouldSendContentAvailable = true
        privateSubscription.notificationInfo = privateNotificationInfo
        
        do {
            _ = try await privateDB.save(privateSubscription)
            log("Private database subscription created", category: "CloudKitChatManager")
        } catch let error as CKError where error.code == .serverRecordChanged {
            // „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÅåÊó¢„Å´Â≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
            log("Private database subscription already exists", category: "CloudKitChatManager")
        }
        
        // ÂÖ±ÊúâDB„ÅÆÂ§âÊõ¥„ÇÇÁõ£Ë¶ñÔºà‰ªñ‰∫∫„Åã„ÇâÂÖ±Êúâ„Åï„Çå„Åü„Éá„Éº„Çø„ÅÆÂ§âÊõ¥„ÇíÊ§úÁü•Ôºâ
        let sharedSubscription = CKDatabaseSubscription(subscriptionID: "shared-database-changes")
        
        let sharedNotificationInfo = CKSubscription.NotificationInfo()
        sharedNotificationInfo.shouldSendContentAvailable = true
        sharedSubscription.notificationInfo = sharedNotificationInfo
        
        do {
            _ = try await sharedDB.save(sharedSubscription)
            log("Shared database subscription created", category: "CloudKitChatManager")
        } catch let error as CKError where error.code == .serverRecordChanged {
            // „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÅåÊó¢„Å´Â≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
            log("Shared database subscription already exists", category: "CloudKitChatManager")
        }
        
        // Áä∂ÊÖã„ÉÄ„É≥„Éó
        do {
            let privateSubs = try await privateDB.allSubscriptions()
            log("üì´ Private subscriptions: \(privateSubs.map{ $0.subscriptionID }.joined(separator: ", "))", category: "CloudKitChatManager")
        } catch {
            log("‚ö†Ô∏è Failed to list private subscriptions: \(error)", category: "CloudKitChatManager")
        }
        do {
            let sharedSubs = try await sharedDB.allSubscriptions()
            log("üì´ Shared subscriptions: \(sharedSubs.map{ $0.subscriptionID }.joined(separator: ", "))", category: "CloudKitChatManager")
        } catch {
            log("‚ö†Ô∏è Failed to list shared subscriptions: \(error)", category: "CloudKitChatManager")
        }
    }
    
    /// ÁâπÂÆö„ÅÆ„É´„Éº„É†Áî®„ÅÆ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇíË®≠ÂÆö
    func setupRoomSubscription(for roomID: String) async throws {
        let predicate = NSPredicate(format: "roomID == %@", roomID)
        let subscription = CKQuerySubscription(
            recordType: "CD_Message",
            predicate: predicate,
            subscriptionID: "messages-\(roomID)",
            options: [.firesOnRecordCreation, .firesOnRecordUpdate, .firesOnRecordDeletion]
        )
        
        let notificationInfo = CKSubscription.NotificationInfo()
        notificationInfo.shouldSendContentAvailable = true
        notificationInfo.desiredKeys = ["body", "senderID", "createdAt"]
        subscription.notificationInfo = notificationInfo
        
        do {
            _ = try await privateDB.save(subscription)
            log("Room subscription created for: \(roomID)", category: "CloudKitChatManager")
        } catch let error as CKError where error.code == .serverRecordChanged {
            log("Room subscription already exists for: \(roomID)", category: "CloudKitChatManager")
        }
    }
    
    // MARK: - Anniversary Operations
    
    /// Ë®òÂøµÊó•„Çí„Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰øùÂ≠ò
    func saveAnniversary(title: String, date: Date, roomID: String, repeatType: RepeatType = .none) async throws -> String {
        guard let roomRecord = await getRoomRecord(for: roomID) else {
            throw CloudKitChatError.roomNotFound
        }
        
        // roomRecord„Å®Âêå„Åò„Çæ„Éº„É≥„Çí‰ΩøÁî®ÔºàÂÖ±Êúâ„Çæ„Éº„É≥Ôºâ
        let anniversaryRecord = CKRecord(recordType: "CD_Anniversary", 
                                       recordID: CKRecord.ID(zoneID: roomRecord.recordID.zoneID))
        
        anniversaryRecord["roomID"] = roomID
        anniversaryRecord["title"] = title
        anniversaryRecord["annivDate"] = date
        anniversaryRecord["repeatType"] = repeatType.rawValue
        anniversaryRecord["createdAt"] = Date()
        
        // CloudKitÊ®ôÊ∫ñÔºöË¶™„É¨„Ç≥„Éº„ÉâÂèÇÁÖß„ÇíË®≠ÂÆöÔºàÂêå„Åò„Çæ„Éº„É≥ÂÜÖÔºâ
        anniversaryRecord.setParent(roomRecord)
        
        // Ê§úÁ¥¢Áî®Ë£úÂä©„Å®„Åó„Å¶roomID„Éï„Ç£„Éº„É´„Éâ„ÇÇ‰ΩµÁî®
        
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰øùÂ≠òÔºàCKShare„Å´„Çà„ÇäËá™ÂãïÁöÑ„Å´ÂÖ±Êúâ„Åï„Çå„ÇãÔºâ
        let savedRecord = try await privateDB.save(anniversaryRecord)
        log("Anniversary saved to private DB shared zone: \(savedRecord.recordID.recordName)", category: "CloudKitChatManager")
        
        return savedRecord.recordID.recordName
    }
    
    /// Ë®òÂøµÊó•„ÅÆÊõ¥Êñ∞
    func updateAnniversary(recordName: String, title: String, date: Date) async throws {
        let recordID = CKRecord.ID(recordName: recordName)
        let record = try await privateDB.record(for: recordID)
        record["title"] = title
        record["annivDate"] = date
        _ = try await privateDB.save(record)
        log("Anniversary updated: \(recordName)", category: "CloudKitChatManager")
    }
    
    /// Ë®òÂøµÊó•„ÅÆÂâäÈô§
    func deleteAnniversary(recordName: String) async throws {
        let recordID = CKRecord.ID(recordName: recordName)
        _ = try await privateDB.deleteRecord(withID: recordID)
        log("Anniversary deleted: \(recordName)", category: "CloudKitChatManager")
    }
    
    // MARK: - Reaction Management
    
    /// „É°„ÉÉ„Çª„Éº„Ç∏„Å´„É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÁµµÊñáÂ≠ó„ÇíËøΩÂä†
    func addReactionToMessage(recordName: String, emoji: String) async throws {
        let recordID = CKRecord.ID(recordName: recordName)
        let record = try await privateDB.record(for: recordID)
        
        // ÁèæÂú®„ÅÆ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÊñáÂ≠óÂàó„ÇíÂèñÂæó
        let currentReactions = record["reactions"] as? String ?? ""
        
        // ÁµµÊñáÂ≠ó„ÇíËøΩÂä†ÔºàÂçòÁ¥î„Å´ÊñáÂ≠óÂàó„Å´ËøΩÂä†Ôºâ
        let updatedReactions = currentReactions + emoji
        record["reactions"] = updatedReactions
        
        _ = try await privateDB.save(record)
        
        log("Added reaction \(emoji) to message: \(recordName)", category: "CloudKitChatManager")
    }
    
    // MARK: - Profile Management („Éó„É©„Ç§„Éô„Éº„ÉàDB + ÂÖ±ÊúâDBÂêåÊúü)
    
    /// „Éû„Çπ„Çø„Éº„Éó„É≠„Éï„Ç£„Éº„É´„Çí„Éó„É©„Ç§„Éô„Éº„ÉàDB„Å´‰øùÂ≠òÔºà„Ç¢„Éó„É™Ë®≠ÂÆö„Åã„ÇâÔºâ
    func saveMasterProfile(name: String, avatarData: Data? = nil) async throws {
        guard let userID = currentUserID else {
            throw CloudKitChatError.userNotAuthenticated
        }
        
        let record = CKRecord(recordType: "CD_Profile", recordID: CKRecord.ID(recordName: "profile-\(userID)"))
        record["userID"] = userID
        record["displayName"] = name
        record["updatedAt"] = Date()
        
        // „Ç¢„Éê„Çø„ÉºÁîªÂÉè„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØCKAsset„Å®„Åó„Å¶‰øùÂ≠ò
        if let avatarData = avatarData, !avatarData.isEmpty {
            let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent("\(UUID().uuidString).jpg")
            try avatarData.write(to: tempURL)
            record["avatar"] = CKAsset(fileURL: tempURL)
        }
        
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„Å´‰øùÂ≠ò
        _ = try await privateDB.save(record)
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•„ÇíÊõ¥Êñ∞
        profileCache[userID] = (name: name, avatarData: avatarData)
        
        log("Master profile saved to private DB for userID: \(userID)", category: "CloudKitChatManager")
        
        // Êó¢Â≠ò„ÅÆÂÖ®„ÉÅ„É£„ÉÉ„Éà„É´„Éº„É†„Å´„Éó„É≠„Éï„Ç£„Éº„É´„ÇíÂêåÊúü
        await syncProfileToAllChats(name: name, avatarData: avatarData)
    }
    
    /// „Éó„É≠„Éï„Ç£„Éº„É´„Çí„ÉÅ„É£„ÉÉ„ÉàÂèÇÂä†ÊôÇ„Å´ÂÖ±Êúâ„Çæ„Éº„É≥„Å´ÂêåÊúü
    func syncProfileToChat(roomID: String) async throws {
        guard let userID = currentUserID else {
            throw CloudKitChatError.userNotAuthenticated
        }
        
        // „Éû„Çπ„Çø„Éº„Éó„É≠„Éï„Ç£„Éº„É´„ÇíÂèñÂæó
        let masterProfile = await fetchMasterProfile()
        
        guard let roomRecord = await getRoomRecord(for: roomID) else {
            throw CloudKitChatError.roomNotFound
        }
        
        // roomRecord„Å®Âêå„Åò„Çæ„Éº„É≥„Çí‰ΩøÁî®ÔºàÂÖ±Êúâ„Çæ„Éº„É≥Ôºâ
        let profileRecord = CKRecord(recordType: "CD_Profile", 
                                   recordID: CKRecord.ID(recordName: "profile-\(userID)", zoneID: roomRecord.recordID.zoneID))
        
        profileRecord["userID"] = userID
        profileRecord["displayName"] = masterProfile.name ?? ""
        profileRecord["updatedAt"] = Date()
        
        // „Ç¢„Éê„Çø„ÉºÁîªÂÉè„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØCKAsset„Å®„Åó„Å¶‰øùÂ≠ò
        if let avatarData = masterProfile.avatarData, !avatarData.isEmpty {
            let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent("\(UUID().uuidString).jpg")
            try avatarData.write(to: tempURL)
            profileRecord["avatar"] = CKAsset(fileURL: tempURL)
        }
        
        // CloudKitÊ®ôÊ∫ñÔºöË¶™„É¨„Ç≥„Éº„ÉâÂèÇÁÖß„ÇíË®≠ÂÆöÔºàÂêå„Åò„Çæ„Éº„É≥ÂÜÖÔºâ
        profileRecord.setParent(roomRecord)
        
        // Ê§úÁ¥¢Áî®Ë£úÂä©„Å®„Åó„Å¶userID„Éï„Ç£„Éº„É´„Éâ„ÇÇ‰ΩµÁî®
        
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´‰øùÂ≠òÔºàCKShare„Å´„Çà„ÇäËá™ÂãïÁöÑ„Å´ÂÖ±Êúâ„Åï„Çå„ÇãÔºâ
        _ = try await privateDB.save(profileRecord)
        
        log("Profile synced to private DB shared zone for roomID: \(roomID)", category: "CloudKitChatManager")
    }
    
    /// „Éû„Çπ„Çø„Éº„Éó„É≠„Éï„Ç£„Éº„É´„Çí„Éó„É©„Ç§„Éô„Éº„ÉàDB„Åã„ÇâÂèñÂæó
    func fetchMasterProfile() async -> (name: String?, avatarData: Data?) {
        guard let userID = currentUserID else {
            return (name: nil, avatarData: nil)
        }
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„ÇâÁ¢∫Ë™ç
        if let cached = profileCache[userID] {
            return cached
        }
        
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„Åã„ÇâÂèñÂæó
        let recordID = CKRecord.ID(recordName: "profile-\(userID)")
        
        do {
            let record = try await privateDB.record(for: recordID)
            let name = record["displayName"] as? String
            var avatarData: Data? = nil
            
            if let asset = record["avatar"] as? CKAsset,
               let url = asset.fileURL,
               let data = try? Data(contentsOf: url) {
                avatarData = data
            }
            
            // „Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠ò
            let result = (name: name, avatarData: avatarData)
            profileCache[userID] = result
            
            log("Master profile fetched from private DB for userID: \(userID)", category: "CloudKitChatManager")
            return result
            
        } catch {
            log("Failed to fetch master profile for userID: \(userID), error: \(error)", category: "CloudKitChatManager")
            return (name: nil, avatarData: nil)
        }
    }
    
    /// „ÉÅ„É£„ÉÉ„ÉàÁî®„Éó„É≠„Éï„Ç£„Éº„É´„Çí„Éó„É©„Ç§„Éô„Éº„ÉàDB„Åã„ÇâÂèñÂæó
    func fetchProfile(for userID: String) async -> (name: String?, avatarData: Data?) {
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„ÇâÁ¢∫Ë™ç
        if let cached = profileCache[userID] {
            return cached
        }
        
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„Åã„ÇâÊ§úÁ¥¢ÔºàuserID„ÅßÊ§úÁ¥¢Ôºâ
        let predicate = NSPredicate(format: "userID == %@", userID)
        let query = CKQuery(recordType: "CD_Profile", predicate: predicate)
        
        do {
            let (results, _) = try await privateDB.records(matching: query)
            
            for (_, result) in results {
                if let record = try? result.get() {
                    let name = record["displayName"] as? String
                    var avatarData: Data? = nil
                    
                    if let asset = record["avatar"] as? CKAsset,
                       let url = asset.fileURL,
                       let data = try? Data(contentsOf: url) {
                        avatarData = data
                    }
                    
                    // „Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠ò
                    let result = (name: name, avatarData: avatarData)
                    profileCache[userID] = result
                    
                    log("Chat profile fetched from private DB for userID: \(userID)", category: "CloudKitChatManager")
                    return result
                }
            }
        } catch {
            log("Failed to fetch chat profile for userID: \(userID), error: \(error)", category: "CloudKitChatManager")
        }
        
        return (name: nil, avatarData: nil)
    }
    
    /// „Éó„É≠„Éï„Ç£„Éº„É´„ÇíÂÖ®„ÉÅ„É£„ÉÉ„Éà„Å´ÂêåÊúü
    private func syncProfileToAllChats(name: String, avatarData: Data?) async {
        guard self.currentUserID != nil else {
            log("‚ùå Cannot sync profile to all chats: currentUserID is nil", category: "CloudKitChatManager")
            return
        }
        
        // Áµ±‰∏ÄÂÖ±Êúâ„Çæ„Éº„É≥„Åã„ÇâÂèÇÂä†„Åó„Å¶„ÅÑ„Çã„É´„Éº„É†„ÇíÂèñÂæó
        let ownedRooms = await getOwnedRooms()
        let participatingRooms = await getParticipatingRooms()
        let allRoomIDs = ownedRooms + participatingRooms
        
        for roomID in allRoomIDs {
            do {
                try await syncProfileToChat(roomID: roomID)
                log("Profile synced to room: \(roomID)", category: "CloudKitChatManager")
            } catch {
                log("Failed to sync profile to room \(roomID): \(error)", category: "CloudKitChatManager")
            }
        }
    }
    
    /// „Éó„É≠„Éï„Ç£„Éº„É´„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢
    func clearProfileCache() {
        profileCache.removeAll()
        log("Profile cache cleared", category: "CloudKitChatManager")
    }
    
    // MARK: - Utility Methods
    
    /// CloudKit „Ç¢„Ç´„Ç¶„É≥„ÉàÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
    func checkAccountStatus() async -> CKAccountStatus {
        do {
            return try await container.accountStatus()
        } catch {
            log("Failed to check account status: \(error)", category: "CloudKitChatManager")
            return .couldNotDetermine
        }
    }
    
    /// Êú¨Áï™Áí∞Â¢É„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö
    func checkIsProductionEnvironment() async -> Bool {
        // „Ç®„É≥„Çø„Ç§„Éà„É´„É°„É≥„ÉàÂÜÖ„ÅÆaps-environment„ÇíÁ¢∫Ë™ç
        guard let path = Bundle.main.path(forResource: "forMarin", ofType: "entitlements"),
              let plist = NSDictionary(contentsOfFile: path),
              let apsEnvironment = plist["aps-environment"] as? String else {
            log("Could not determine environment from entitlements", category: "CloudKitChatManager")
            return false // ‰∏çÊòé„Å™Â†¥Âêà„ÅØÈñãÁô∫Áí∞Â¢É„Å®„Åó„Å¶Êâ±„ÅÜ
        }
        
        let isProduction = apsEnvironment == "production"
        log("Environment detected: \(apsEnvironment) (isProduction: \(isProduction))", category: "CloudKitChatManager")
        return isProduction
    }
    
    /// „Ç®„É©„ÉºÊôÇ„ÅÆËá™Âãï„É™„Çª„ÉÉ„ÉàÔºàÊú¨Áï™Áí∞Â¢É„Åß„ÇÇÊúâÂäπÔºâ
    func performEmergencyReset(reason: String) async throws {
        log("üö® Emergency reset requested: \(reason)", category: "CloudKitChatManager")
        
        let isProduction = await checkIsProductionEnvironment()
        
        if isProduction {
            log("‚ö†Ô∏è Production emergency reset initiated", category: "CloudKitChatManager")
            // Êú¨Áï™Áí∞Â¢É„Åß„ÅØËøΩÂä†„ÅÆÂÆâÂÖ®„ÉÅ„Çß„ÉÉ„ÇØ„ÇíÂÆüË°å
            guard await validateEmergencyResetConditions() else {
                log("‚ùå Emergency reset conditions not met", category: "CloudKitChatManager")
                throw CloudKitChatError.resetFailed
            }
        }
        
        do {
            try await performCompleteReset(bypassSafetyCheck: true)
            log("‚úÖ Emergency reset completed successfully", category: "CloudKitChatManager")
            
            // „É™„Çª„ÉÉ„ÉàÂæå„ÅÆÂÜçÂàùÊúüÂåñ
            await initialize()
            
        } catch {
            log("‚ùå Emergency reset failed: \(error)", category: "CloudKitChatManager")
            throw CloudKitChatError.resetFailed
        }
    }
    
    /// Á∑äÊÄ•„É™„Çª„ÉÉ„Éà„ÅÆÊù°‰ª∂„ÇíÊ§úË®º
    private func validateEmergencyResetConditions() async -> Bool {
        // Êú¨Áï™Áí∞Â¢É„Åß„ÅÆÁ∑äÊÄ•„É™„Çª„ÉÉ„ÉàÊù°‰ª∂„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        
        // 1. ÈáçË¶Å„Ç®„É©„Éº„ÅåË§áÊï∞ÂõûÁô∫Áîü„Åó„Å¶„ÅÑ„Çã
        // 2. „Ç¢„Éó„É™„ÅåÂÆåÂÖ®„Å´Ê©üËÉΩ„Åó„Å™„ÅÑÁä∂ÊÖã
        // 3. „Éá„Éº„ÇøÁ†¥Êêç„ÅåÊ§úÂá∫„Åï„Çå„Å¶„ÅÑ„Çã
        
        log("Validating emergency reset conditions...", category: "CloudKitChatManager")
        
        // CloudKitÊé•Á∂ö„ÉÜ„Çπ„Éà
        let accountStatus = await checkAccountStatus()
        guard accountStatus == .available else {
            log("CloudKit account not available", category: "CloudKitChatManager")
            return false
        }
        
        // „Éá„Éº„ÇøÊï¥ÂêàÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
        let dataCorrupted = await checkDataIntegrity()
        if dataCorrupted {
            log("Data corruption detected - emergency reset approved", category: "CloudKitChatManager")
            return true
        }
        
        // „Åù„ÅÆ‰ªñ„ÅÆÊù°‰ª∂...
        log("Emergency reset conditions validated", category: "CloudKitChatManager")
        return true
    }
    
    /// „Éá„Éº„ÇøÊï¥ÂêàÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    private func checkDataIntegrity() async -> Bool {
        do {
            // Âü∫Êú¨ÁöÑ„Å™„ÇØ„Ç®„É™„ÇíÂÆüË°å„Åó„Å¶„Éá„Éº„Çø„Ç¢„ÇØ„Çª„Çπ„Çí„ÉÜ„Çπ„Éà
            let query = CKQuery(recordType: "CD_ChatRoom", predicate: NSPredicate(value: true))
            _ = try await privateDB.records(matching: query, resultsLimit: 1)
            return false // „Ç®„É©„Éº„Å™„Åó = Á†¥Êêç„Å™„Åó
        } catch {
            log("Data integrity check failed: \(error)", category: "CloudKitChatManager")
            return true // „Ç®„É©„Éº„ÅÇ„Çä = Á†¥Êêç„ÅÆÂèØËÉΩÊÄß
        }
    }
    
    /// „Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢
    func clearCache() {
        profileCache.removeAll()
        log("Profile cache cleared (room/share caches removed in unified zone implementation)", category: "CloudKitChatManager")
    }
    
    // MARK: - Unified Reset Functions
    
    /// „É≠„Éº„Ç´„É´„É™„Çª„ÉÉ„ÉàÔºöCloudKit„Éá„Éº„Çø„Å´Ëß¶„Çå„Åö„Å´„É≠„Éº„Ç´„É´„Ç≠„É£„ÉÉ„Ç∑„É•„Å®„Ç¢„Éó„É™Áä∂ÊÖã„ÅÆ„Åø„ÇØ„É™„Ç¢
    func performLocalReset() async throws {
        log("Starting local reset...", category: "CloudKitChatManager")
        
        // 1. „É≠„Éº„Ç´„É´„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢
        clearCache()
        
        // 2. UserDefaults „Çí„ÇØ„É™„Ç¢
        clearUserDefaults()
        
        // 3. ÂàùÊúüÂåñÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„ÉàÔºà„Åü„Å†„ÅóCloudKit„Éá„Éº„Çø„ÅØ‰øùÊåÅÔºâ
        profileCache.removeAll()
        lastError = nil
        
        log("Local reset completed successfully", category: "CloudKitChatManager")
    }
    
    /// „ÇØ„É©„Ç¶„Éâ„ÇíÂê´„ÇÅ„ÅüÂÆåÂÖ®„É™„Çª„ÉÉ„ÉàÔºöCloudKit„Éá„Éº„Çø„ÇíÂê´„ÇÄÂÖ®„Éá„Éº„Çø„ÇíÂâäÈô§
    func performCompleteCloudReset() async throws {
        log("Starting complete cloud reset...", category: "CloudKitChatManager")
        
        // Êú¨Áï™Áí∞Â¢É„Åß„ÅÆÂÆâÂÖ®„ÉÅ„Çß„ÉÉ„ÇØ
        let isProduction = await checkIsProductionEnvironment()
        if isProduction {
            log("‚ö†Ô∏è Production cloud reset requires explicit confirmation", category: "CloudKitChatManager")
            // UIÂÅ¥„ÅßÁ¢∫Ë™ç„ÇíÊ±Ç„ÇÅ„Çã
        }
        
        do {
            // Êó¢Â≠ò„ÅÆÂÆåÂÖ®„É™„Çª„ÉÉ„ÉàÊ©üËÉΩ„Çí‰ΩøÁî®
            try await performCompleteReset(bypassSafetyCheck: true)
            log("Complete cloud reset finished successfully", category: "CloudKitChatManager")
            
        } catch {
            log("‚ùå Complete cloud reset failed: \(error)", category: "CloudKitChatManager")
            throw CloudKitChatError.resetFailed
        }
    }
    
    // MARK: - Complete Reset Functions
    
    /// ÂÆåÂÖ®„É™„Çª„ÉÉ„ÉàÔºöÂÖ®„Éá„Éº„Çø„ÇíÂâäÈô§„Åó„Å¶ÂàùÊúüÁä∂ÊÖã„Å´Êàª„ÅôÔºàÊú¨Áï™Áí∞Â¢ÉÂØæÂøúÔºâ
    func performCompleteReset(bypassSafetyCheck: Bool = false) async throws {
        log("Starting complete reset...", category: "CloudKitChatManager")
        
        // Êú¨Áï™Áí∞Â¢É„Åß„ÅÆÂÆâÂÖ®„ÉÅ„Çß„ÉÉ„ÇØ
        let isProduction = await checkIsProductionEnvironment()
        if isProduction && !bypassSafetyCheck {
            log("‚ö†Ô∏è Production reset requires safety check bypass", category: "CloudKitChatManager")
            throw CloudKitChatError.productionResetBlocked
        }
        
        do {
            // 1. „É≠„Éº„Ç´„É´„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢
            clearCache()
            
            // 2. CloudKit „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇíÂâäÈô§
            try await removeAllSubscriptions()
            
            // 3. „Éó„É©„Ç§„Éô„Éº„ÉàDB „ÅÆÂÖ®„Éá„Éº„Çø„ÇíÂâäÈô§
            try await clearPrivateDatabase()
            
            // 4. ÂÖ±ÊúâDB „Åã„ÇâÈõ¢ËÑ±
            try await leaveAllSharedDatabases()
            
            // 5. UserDefaults „Çí„ÇØ„É™„Ç¢
            clearUserDefaults()
            
            // 6. ÂàùÊúüÂåñÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
            currentUserID = nil
            isInitialized = false
            lastError = nil
            
            log("Complete reset finished successfully", category: "CloudKitChatManager")
            
        } catch {
            log("‚ùå Complete reset failed: \(error)", category: "CloudKitChatManager")
            throw CloudKitChatError.resetFailed
        }
    }
    
    /// Êóß„Éá„Éº„ÇøÊ§úÂá∫ÊôÇ„ÅÆËá™Âãï„É™„Çª„ÉÉ„Éà
    func resetIfLegacyDataDetected() async throws {
        let hasLegacyData = await detectLegacyData()
        
        if hasLegacyData {
            log("Legacy data detected, performing automatic reset", category: "CloudKitChatManager")
            try await performCompleteReset(bypassSafetyCheck: true)
            
            // „É™„Çª„ÉÉ„ÉàÂÆüË°å„Éï„É©„Ç∞„ÇíË®≠ÂÆö
            hasPerformedReset = true
            
            // „É™„Çª„ÉÉ„ÉàÂæå„Å´ÂÜçÂàùÊúüÂåñ
            await initialize()
        }
    }
    
    /// Êóß„Éá„Éº„Çø„ÅÆÊ§úÂá∫
    private func detectLegacyData() async -> Bool {
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅßÊóßÂΩ¢Âºè„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊ§úÁ¥¢
        let predicate = NSPredicate(format: "recordID CONTAINS %@", "_room")
        let query = CKQuery(recordType: "CD_Message", predicate: predicate)
        
        do {
            let (results, _) = try await privateDB.records(matching: query)
            
            if !results.isEmpty {
                log("Legacy message format detected", category: "CloudKitChatManager")
                return true
            }
        } catch {
            log("Error searching legacy messages: \(error)", category: "CloudKitChatManager")
        }
        
        // ÊóßÂΩ¢Âºè„ÅÆ„ÉÅ„É£„ÉÉ„Éà„É´„Éº„É†„ÇíÊ§úÁ¥¢
        let roomQuery = CKQuery(recordType: "CD_ChatRoom", predicate: NSPredicate(value: true))
        
        do {
            let (roomResults, _) = try await privateDB.records(matching: roomQuery)
            
            for (_, result) in roomResults {
                if let record = try? result.get(),
                   let roomID = record["roomID"] as? String,
                   roomID.contains("_room") {
                    log("Legacy room format detected", category: "CloudKitChatManager")
                    return true
                }
            }
        } catch {
            log("Error searching legacy rooms: \(error)", category: "CloudKitChatManager")
        }
        
        return false
    }
    
    /// ÂÖ®„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇíÂâäÈô§
    private func removeAllSubscriptions() async throws {
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥ÂâäÈô§
        let privateSubscriptions = try await privateDB.allSubscriptions()
        let privateIDs = privateSubscriptions.map { $0.subscriptionID }
        if !privateIDs.isEmpty {
            _ = try await privateDB.modifySubscriptions(saving: [], deleting: privateIDs)
            log("Removed \(privateIDs.count) private subscriptions", category: "CloudKitChatManager")
        }
        
        // ÂÖ±ÊúâDB„ÅÆ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥ÂâäÈô§
        let sharedSubscriptions = try await sharedDB.allSubscriptions()
        let sharedIDs = sharedSubscriptions.map { $0.subscriptionID }
        if !sharedIDs.isEmpty {
            _ = try await sharedDB.modifySubscriptions(saving: [], deleting: sharedIDs)
            log("Removed \(sharedIDs.count) shared subscriptions", category: "CloudKitChatManager")
        }
    }
    
    /// „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ®„Éá„Éº„Çø„ÇíÂâäÈô§Ôºà„ÉÅ„É£„ÉÉ„Éà„É™„Çπ„Éà + „Éû„Çπ„Çø„Éº„Éó„É≠„Éï„Ç£„Éº„É´Ôºâ
    private func clearPrivateDatabase() async throws {
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅØ„ÉÅ„É£„ÉÉ„Éà„É™„Çπ„ÉàÁÆ°ÁêÜ„Å®„Éû„Çπ„Çø„Éº„Éó„É≠„Éï„Ç£„Éº„É´ÁÆ°ÁêÜ„Å´‰ΩøÁî®
        let recordTypes = ["CD_ChatRoom", "CD_Profile"]
        
        for recordType in recordTypes {
            do {
                let query = CKQuery(recordType: recordType, predicate: NSPredicate(value: true))
                let (results, _) = try await privateDB.records(matching: query)
                
                let recordIDsToDelete = results.compactMap { (recordID, result) -> CKRecord.ID? in
                    switch result {
                    case .success:
                        return recordID
                    case .failure:
                        return nil
                    }
                }
                
                if !recordIDsToDelete.isEmpty {
                    _ = try await privateDB.modifyRecords(saving: [], deleting: recordIDsToDelete)
                    log("Deleted \(recordIDsToDelete.count) records of type \(recordType)", category: "CloudKitChatManager")
                }
            } catch {
                log("Error deleting \(recordType): \(error)", category: "CloudKitChatManager")
            }
        }
        
        // „Ç´„Çπ„Çø„É†„Çæ„Éº„É≥„ÇÇÂâäÈô§
        try await clearCustomZones()
    }
    
    /// „Ç´„Çπ„Çø„É†„Çæ„Éº„É≥„ÇíÂâäÈô§
    private func clearCustomZones() async throws {
        let zones = try await privateDB.allRecordZones()
        let customZones = zones.filter { !$0.zoneID.zoneName.hasPrefix("_") }
        
        if !customZones.isEmpty {
            let zoneIDs = customZones.map { $0.zoneID }
            _ = try await privateDB.modifyRecordZones(saving: [], deleting: zoneIDs)
            log("Deleted \(zoneIDs.count) custom zones", category: "CloudKitChatManager")
        }
    }
    
    /// ÂÖ±Êúâ„Çæ„Éº„É≥„Åã„ÇâÈõ¢ËÑ±Ôºà„Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„É¨„Ç≥„Éº„Éâ„ÇíÂâäÈô§Ôºâ
    private func leaveAllSharedDatabases() async throws {
        // „Éó„É©„Ç§„Éô„Éº„ÉàDB„ÅÆÂÖ±Êúâ„Çæ„Éº„É≥„Å´„ÅÇ„ÇãÂÖ®„Å¶„ÅÆ„É¨„Ç≥„Éº„Éâ„ÇíÂâäÈô§
        // ÂÖ±Êúâ„Çæ„Éº„É≥ÂÜÖ„ÅÆ„É¨„Ç≥„Éº„Éâ„ÇíÂâäÈô§„Åô„Çã„Åì„Å®„ÅßÂÖ±Êúâ„Åã„Çâ„ÅÆÈõ¢ËÑ±„Å®ÂêåÁ≠â„ÅÆÂäπÊûú„ÇíÂæó„Çã
        let recordTypes = ["CD_Message", "CD_ChatRoom", "CD_Anniversary", "CD_Profile"]
        
        for recordType in recordTypes {
            do {
                let query = CKQuery(recordType: recordType, predicate: NSPredicate(value: true))
                let (results, _) = try await privateDB.records(matching: query)
                
                let recordIDsToDelete = results.compactMap { (recordID, result) -> CKRecord.ID? in
                    switch result {
                    case .success:
                        return recordID
                    case .failure:
                        return nil
                    }
                }
                
                if !recordIDsToDelete.isEmpty {
                    _ = try await privateDB.modifyRecords(saving: [], deleting: recordIDsToDelete)
                    log("Deleted \(recordIDsToDelete.count) private DB records of type \(recordType)", category: "CloudKitChatManager")
                }
            } catch {
                log("Error deleting private DB \(recordType): \(error)", category: "CloudKitChatManager")
            }
        }
    }
    
    /// UserDefaults„ÅÆÈñ¢ÈÄ£„Éá„Éº„Çø„Çí„ÇØ„É™„Ç¢
    private func clearUserDefaults() {
        let defaults = UserDefaults.standard
        
        // „ÉÅ„É£„ÉÉ„ÉàÈñ¢ÈÄ£„ÅÆ„Ç≠„Éº„Çí„ÇØ„É™„Ç¢
        let keysToRemove = [
            "recentEmojis",
            "autoDownloadImages",
            "hasSeenWelcome"
        ]
        
        for key in keysToRemove {
            defaults.removeObject(forKey: key)
        }
        
        // „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„Éï„É©„Ç∞„Çí„ÇØ„É™„Ç¢
        let allKeys = defaults.dictionaryRepresentation().keys
        for key in allKeys {
            if key.hasPrefix("didSeedTutorial_") {
                defaults.removeObject(forKey: key)
            }
        }
        
        defaults.synchronize()
        log("UserDefaults cleared", category: "CloudKitChatManager")
    }

    // MARK: - Diagnostics Utilities
    
    /// „Çæ„Éº„É≥‰∏ÄË¶ß„Å®ÂÖ±ÊúâÁä∂ÊÖã„ÇíÂá∫Âäõ
    private func dumpZoneList() async {
        do {
            let zones = try await privateDB.allRecordZones()
            let zoneNames = zones.map { $0.zoneID.zoneName }.joined(separator: ", ")
            log("üìÅ Private DB zones: [\(zoneNames)]", category: "CloudKitChatManager")
        } catch {
            log("‚ö†Ô∏è Failed to list private DB zones: \(error)", category: "CloudKitChatManager")
        }
        do {
            let zones = try await sharedDB.allRecordZones()
            let zoneNames = zones.map { $0.zoneID.zoneName }.joined(separator: ", ")
            log("üìÅ Shared DB zones: [\(zoneNames)]", category: "CloudKitChatManager")
        } catch {
            log("‚ö†Ô∏è Failed to list shared DB zones: \(error)", category: "CloudKitChatManager")
        }
    }
    
    /// „Éá„Éº„Çø„Éô„Éº„ÇπÂÖ®‰Ωì„ÅÆÁä∂ÊÖã„ÇíÂèØË¶ñÂåñÔºà„É≠„Ç∞ÂèéÈõÜÈÄ£Êê∫Ôºâ
    func dumpDatabaseState(roomID: String? = nil) async {
        // „Ç¢„Ç´„Ç¶„É≥„ÉàÁä∂ÊÖã
        let status = await checkAccountStatus()
        log("üë§ CKAccountStatus: \(status.rawValue)", category: "CloudKitChatManager")
        log("üß© CKContainer: iCloud.forMarin-test", category: "CloudKitChatManager")
        
        // „Çæ„Éº„É≥‰∏ÄË¶ß
        await dumpZoneList()
        
        // SharedRoomsÂÜÖ„ÅÆChatRoomÂàóÊåô
        do {
            let sharedZoneID = CKRecordZone.ID(zoneName: "SharedRooms")
            let query = CKQuery(recordType: "CD_ChatRoom", predicate: NSPredicate(value: true))
            let (results, _) = try await privateDB.records(matching: query, inZoneWith: sharedZoneID)
            let rooms: [CKRecord] = results.compactMap { try? $0.1.get() }
            log("üè† ChatRooms in SharedRooms: \(rooms.count)", category: "CloudKitChatManager")
            for r in rooms.prefix(10) {
                let rid = r["roomID"] as? String ?? "nil"
                let createdBy = r["createdBy"] as? String ?? "nil"
                let participants = (r["participants"] as? [String])?.joined(separator: ", ") ?? "nil"
                log("üè† Room: record=\(r.recordID.recordName), roomID=\(rid), createdBy=\(createdBy), participants=[\(participants)]", category: "CloudKitChatManager")
            }
        } catch {
            log("‚ö†Ô∏è Failed to list ChatRooms in SharedRooms: \(error)", category: "CloudKitChatManager")
        }
        
        // cloudkit.share „ÅÆÂàóÊåôÔºàrootRecord„ÅÆroomID„ÇíÊé®ÂÆöÔºâ
        do {
            let shareQuery = CKQuery(recordType: "cloudkit.share", predicate: NSPredicate(value: true))
            let (results, _) = try await privateDB.records(matching: shareQuery, resultsLimit: 50)
            let shares = results.compactMap { try? $0.1.get() as? CKShare }
            log("üîó Shares in Private DB: \(shares.count)", category: "CloudKitChatManager")
            for s in shares.prefix(10) {
                let title = s[CKShare.SystemFieldKey.title] as? String ?? "nil"
                let urlStr = s.url?.absoluteString ?? "nil"
                log("üîó Share: root=\(s.recordID.recordName), title=\(title), url=\(urlStr)", category: "CloudKitChatManager")
            }
        } catch {
            log("‚ö†Ô∏è Failed to list cloudkit.share: \(error)", category: "CloudKitChatManager")
        }
        
        // ÂØæË±°roomID„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Çå„Å∞Ë©≥Á¥∞
        if let roomID = roomID {
            await dumpRoomDetails(roomID: roomID)
        }
    }
    
    /// ÁâπÂÆö„É´„Éº„É†„ÅÆË©≥Á¥∞Áä∂ÊÖã
    private func dumpRoomDetails(roomID: String) async {
        log("üî¨ Dumping room details for roomID: \(roomID)", category: "CloudKitChatManager")
        
        // SharedRoomsÂÜÖ„ÅÆÂ≠òÂú®Á¢∫Ë™ç
        do {
            let sharedZoneID = CKRecordZone.ID(zoneName: "SharedRooms")
            let recordID = CKRecord.ID(recordName: roomID, zoneID: sharedZoneID)
            let record = try await privateDB.record(for: recordID)
            let createdBy = record["createdBy"] as? String ?? "nil"
            log("üî¨ Room exists in SharedRooms. createdBy=\(createdBy)", category: "CloudKitChatManager")
            
            // Èñ¢ÈÄ£ShareÊúâÁÑ°
            let shareQuery = CKQuery(recordType: "cloudkit.share", predicate: NSPredicate(format: "rootRecord == %@", record.recordID))
            let (shareResults, _) = try await privateDB.records(matching: shareQuery)
            if let share = try shareResults.first?.1.get() as? CKShare {
                log("üî¨ Room has share. url=\(share.url?.absoluteString ?? "nil")", category: "CloudKitChatManager")
            } else {
                log("üî¨ Room has NO share record", category: "CloudKitChatManager")
            }
        } catch {
            log("üî¨ Room not found in SharedRooms or error: \(error)", category: "CloudKitChatManager")
        }
        
        // „É°„ÉÉ„Çª„Éº„Ç∏Êï∞ÔºàÊúÄËøë„ÅÆ„ÅøÔºâ
        do {
            let predicate = NSPredicate(format: "roomID == %@", roomID)
            let q = CKQuery(recordType: "CD_Message", predicate: predicate)
            let (results, _) = try await privateDB.records(matching: q, resultsLimit: 20)
            let cnt = results.count
            log("üìù Private DB messages (any zone) sample count: \(cnt)", category: "CloudKitChatManager")
        } catch {
            log("‚ö†Ô∏è Failed to count messages: \(error)", category: "CloudKitChatManager")
        }
    }
    
    // MARK: - UserID Management
    
    /// UserIDManager„ÅÆÈÄöÁü•„ÇíË≥ºË™≠
    private func setupUserIDNotifications() {
        NotificationCenter.default.addObserver(
            forName: .userIDMigrationRequired,
            object: nil,
            queue: .main
        ) { [weak self] notification in
            Task { @MainActor in
                await self?.handleUserIDMigration(notification: notification)
            }
        }
        
        NotificationCenter.default.addObserver(
            forName: .legacyDataMigrationRequired,
            object: nil,
            queue: .main
        ) { [weak self] notification in
            Task { @MainActor in
                await self?.handleLegacyDataMigration(notification: notification)
            }
        }
    }
    
    /// „É¶„Éº„Ç∂„ÉºID„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥Âá¶ÁêÜ
    private func handleUserIDMigration(notification: Notification) async {
        guard let userInfo = notification.userInfo,
              let oldUserID = userInfo["oldUserID"] as? String,
              let newUserID = userInfo["newUserID"] as? String else {
            log("Invalid migration notification", category: "CloudKitChatManager")
            return
        }
        
        log("Handling UserID migration: \(oldUserID) -> \(newUserID)", category: "CloudKitChatManager")
        
        // ÁèæÂú®„ÅÆ„É¶„Éº„Ç∂„ÉºID„ÇíÊõ¥Êñ∞
        currentUserID = newUserID
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢ÔºàÂè§„ÅÑ„É¶„Éº„Ç∂„ÉºID„Å´Âü∫„Å•„Åè„Éá„Éº„Çø„ÇíÁÑ°ÂäπÂåñÔºâ
        clearCache()
        
        // ÂøÖË¶Å„Å´Âøú„Åò„Å¶Êó¢Â≠ò„ÅÆ„ÉÅ„É£„ÉÉ„Éà„É´„Éº„É†„ÇíÂÜçÂêåÊúü
        // „Åì„Çå„ÅØË§áÈõë„Å™Âá¶ÁêÜ„ÅÆ„Åü„ÇÅ„ÄÅ„É¶„Éº„Ç∂„Éº„Å´ÂÜç„É≠„Ç∞„Ç§„É≥Á≠â„Çí‰øÉ„Åô„Åì„Å®„ÇÇËÄÉÊÖÆ
        
        log("UserID migration completed", category: "CloudKitChatManager")
        
        // UIÊõ¥Êñ∞„ÅÆ„Åü„ÇÅÈÄöÁü•ÈÄÅ‰ø°
        NotificationCenter.default.post(name: .chatManagerUserIDUpdated, object: nil)
    }
    
    /// Êóß„Éá„Éº„Çø„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥Âá¶ÁêÜ
    private func handleLegacyDataMigration(notification: Notification) async {
        guard let userInfo = notification.userInfo,
              let legacyDeviceID = userInfo["legacyDeviceID"] as? String else {
            log("Invalid legacy migration notification", category: "CloudKitChatManager")
            return
        }
        
        log("Handling legacy data migration for device: \(legacyDeviceID)", category: "CloudKitChatManager")
        
        // Êóß„Éá„Éº„Çø„ÅÆ„ÇØ„É™„Ç¢„Ç¢„ÉÉ„ÉóÂá¶ÁêÜ„ÇíÂÆüË°å
        do {
            try await performCompleteReset()
            log("Legacy data migration completed", category: "CloudKitChatManager")
        } catch {
            log("Legacy data migration failed: \(error)", category: "CloudKitChatManager")
        }
    }
}

// MARK: - Error Types

enum CloudKitChatError: LocalizedError {
    case userNotAuthenticated
    case recordSaveFailed
    case roomNotFound
    case invalidMessage
    case networkUnavailable
    case invalidUserID
    case userNotFound
    case schemaCreationInProgress
    case productionResetBlocked
    case resetFailed
    
    var errorDescription: String? {
        switch self {
        case .userNotAuthenticated:
            return "CloudKit„É¶„Éº„Ç∂„ÉºË™çË®º„ÅåÂøÖË¶Å„Åß„Åô"
        case .recordSaveFailed:
            return "„É¨„Ç≥„Éº„Éâ„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü"
        case .roomNotFound:
            return "„ÉÅ„É£„ÉÉ„Éà„É´„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì"
        case .invalidMessage:
            return "ÁÑ°Âäπ„Å™„É°„ÉÉ„Çª„Éº„Ç∏„Åß„Åô"
        case .networkUnavailable:
            return "„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì"
        case .invalidUserID:
            return "Ëá™ÂàÜËá™Ë∫´„ÅÆID„ÅØÊåáÂÆö„Åß„Åç„Åæ„Åõ„Çì"
        case .userNotFound:
            return "ÊåáÂÆö„Åï„Çå„Åü„É¶„Éº„Ç∂„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì"
        case .schemaCreationInProgress:
            return "„Éá„Éº„Çø„Éô„Éº„ÇπÂàùÊúüÂåñ‰∏≠„Åß„Åô„ÄÇ„Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ"
        case .productionResetBlocked:
            return "Êú¨Áï™Áí∞Â¢É„Åß„ÅÆ„É™„Çª„ÉÉ„Éà„ÅØÂÆâÂÖ®„ÅÆ„Åü„ÇÅ„Éñ„É≠„ÉÉ„ÇØ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇforce=true„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ"
        case .resetFailed:
            return "„Éá„Éº„Çø„É™„Çª„ÉÉ„Éà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü"
        }
    }
}

// MARK: - Notifications

extension Notification.Name {
    static let chatManagerUserIDUpdated = Notification.Name("ChatManagerUserIDUpdated")
    static let disableMessageSync = Notification.Name("DisableMessageSync")
    static let enableMessageSync = Notification.Name("EnableMessageSync")
    static let cloudKitSchemaReady = Notification.Name("CloudKitSchemaReady")
}

