import Foundation
import SwiftData
import Combine
import CloudKit
import UIKit
import SwiftUI

// MARK: - Error Extensions for Offline Management

extension Error {
    var isNetworkError: Bool {
        if let ckError = self as? CKError {
            return ckError.code == .networkUnavailable || 
                   ckError.code == .networkFailure ||
                   ckError.code == .requestRateLimited
        }
        
        if let urlError = self as? URLError {
            return urlError.code == .notConnectedToInternet ||
                   urlError.code == .networkConnectionLost ||
                   urlError.code == .timedOut
        }
        
        return false
    }
}

@MainActor
class MessageStore: ObservableObject {
    @Published private(set) var messages: [Message] = []
    @Published private(set) var isLoading: Bool = false
    @Published private(set) var isSyncing: Bool = false
    
    // „Ç®„É©„Éº„ÅØÂÜÖÈÉ®Âá¶ÁêÜ„Å´Áïô„ÇÅ„Å¶UI„ÅÆÂÜçÊèèÁîª„ÇíÊúÄÂ∞èÂåñ
    private(set) var syncError: Error? {
        didSet {
            if syncError != nil {
                // „Ç®„É©„ÉºÊôÇ„ÅÆ„ÅøÂøÖË¶Å„Å´Âøú„Åò„Å¶UIÈÄöÁü•
                log("Sync error occurred: \(syncError?.localizedDescription ?? "Unknown")", category: "MessageStore")
            }
        }
    }

    
    private let modelContext: ModelContext
    private let roomID: String
    private var cancellables = Set<AnyCancellable>()
    private var notificationTokens: [NSObjectProtocol] = []
    // Ê∑ª‰ªò„Åå„É°„ÉÉ„Çª„Éº„Ç∏Êú¨‰Ωì„Çà„ÇäÂÖà„Å´Â±ä„ÅÑ„ÅüÂ†¥Âêà„ÅÆ‰∏ÄÊôÇ„Ç≠„É£„ÉÉ„Ç∑„É•ÔºàrecordName -> localPathÔºâ
    private var pendingAttachmentPaths: [String: String] = [:]
    
    // Offline support
    private let offlineManager = OfflineManager.shared
    
    init(modelContext: ModelContext, roomID: String) {
        self.modelContext = modelContext
        self.roomID = roomID
        
        log("üèóÔ∏è Initialized with roomID: \(roomID)", category: "MessageStore")
        
        setupSyncSubscriptions()
        loadInitialMessages()
        
        // ÁâπÂÆö„ÅÆ„É´„Éº„É†Áî®„ÅÆPush Notification„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇíË®≠ÂÆö
        setupRoomPushNotifications()
        
        // „Éá„Éê„ÉÉ„Ç∞Âá∫Âäõ/ÂÆöÊúü„ÉÅ„Çß„ÉÉ„ÇØ„ÅØÊäëÂà∂ÔºàÂøÖË¶ÅÊôÇ„Å´ÊòéÁ§∫ÁöÑ„Å´Âëº„Å≥Âá∫„ÅôÔºâ
    }

    deinit {
        for token in notificationTokens {
            NotificationCenter.default.removeObserver(token)
        }
    }
    
    // MARK: - Setup
    
    private func setupSyncSubscriptions() {
        let currentRoomID = self.roomID
        
        if #available(iOS 17.0, *) {
            // NOTE: MessageSyncPipeline ÈÄöÁü•„Éô„Éº„Çπ„ÄÇÊóß MessageSyncService (Combine) „ÅØÂÜçÂ∞éÂÖ•„Åó„Å™„ÅÑ„Åì„Å®„ÄÇ
            let center = NotificationCenter.default

            notificationTokens.append(center.addObserver(forName: .messagePipelineDidReceiveMessage,
                                                          object: nil,
                                                          queue: nil) { [weak self] notification in
                guard let self,
                      let message = notification.userInfo?["message"] as? Message,
                      message.roomID == currentRoomID else { return }
                Task { @MainActor in self.handleReceivedMessage(message) }
            })

            notificationTokens.append(center.addObserver(forName: .messagePipelineDidDeleteMessage,
                                                          object: nil,
                                                          queue: nil) { [weak self] notification in
                guard let self,
                      let messageID = notification.userInfo?["messageID"] as? String else { return }
                Task { @MainActor in self.handleDeletedMessage(messageID) }
            })

            notificationTokens.append(center.addObserver(forName: .messagePipelineDidStart,
                                                          object: nil,
                                                          queue: nil) { [weak self] notification in
                guard let self else { return }
                let roomInfo = notification.userInfo?["roomID"] as? String
                if roomInfo == nil || roomInfo == currentRoomID {
                    Task { @MainActor in self.isSyncing = true }
                }
            })

            notificationTokens.append(center.addObserver(forName: .messagePipelineDidFinish,
                                                          object: nil,
                                                          queue: nil) { [weak self] notification in
                guard let self else { return }
                let roomInfo = notification.userInfo?["roomID"] as? String
                if roomInfo == nil || roomInfo == currentRoomID {
                    Task { @MainActor in self.isSyncing = false }
                }
            })

            notificationTokens.append(center.addObserver(forName: .messagePipelineDidFail,
                                                          object: nil,
                                                          queue: nil) { [weak self] notification in
                guard let self,
                      let error = notification.userInfo?["error"] as? Error else { return }
                let roomInfo = notification.userInfo?["roomID"] as? String
                if roomInfo == nil || roomInfo == currentRoomID {
                    Task { @MainActor in
                        self.syncError = error
                        self.isSyncing = false
                        log("Sync error: \(error)", category: "MessageStore")
                    }
                }
            })

            notificationTokens.append(center.addObserver(forName: .messagePipelineDidUpdateReactions,
                                                          object: nil,
                                                          queue: nil) { [weak self] notification in
                guard let self,
                      let room = notification.userInfo?["roomID"] as? String,
                      room == currentRoomID,
                      let recordName = notification.userInfo?["recordName"] as? String else { return }
                Task { @MainActor in self.refreshReactions(for: recordName) }
            })

            notificationTokens.append(center.addObserver(forName: .messagePipelineDidUpdateAttachment,
                                                          object: nil,
                                                          queue: nil) { [weak self] notification in
                guard let self,
                      let room = notification.userInfo?["roomID"] as? String,
                      room == currentRoomID,
                      let recordName = notification.userInfo?["recordName"] as? String,
                      let localPath = notification.userInfo?["localPath"] as? String else { return }
                Task { @MainActor in
                    if let idx = self.messages.firstIndex(where: { $0.ckRecordName == recordName }) {
                        self.messages[idx].assetPath = localPath
                        do { try self.modelContext.save() } catch { log("Failed to save attachment path: \(error)", category: "MessageStore") }
                        log("Attachment updated for message=\(recordName)", level: "DEBUG", category: "MessageStore")
                    } else {
                        self.pendingAttachmentPaths[recordName] = localPath
                        log("Attachment queued (message not yet in UI): record=\(recordName)", level: "DEBUG", category: "MessageStore")
                    }
                }
            })
        }
        
        // Subscribe to offline manager events
        offlineManager.$isOnline
            .sink { [weak self] isOnline in
                Task { @MainActor in
                    if isOnline { self?.handleNetworkRestored() } else { self?.handleNetworkLost() }
                }
            }
            .store(in: &cancellables)
        
        // Subscribe to failed message notifications
        NotificationCenter.default.publisher(for: .messageFailedPermanently)
            .sink { [weak self] notification in
                Task { @MainActor in
                    if let message = notification.userInfo?["message"] as? Message,
                       message.roomID == currentRoomID {
                        self?.handleMessageFailedPermanently(message)
                    }
                }
            }
            .store(in: &cancellables)
        
        // Subscribe to schema ready notifications
        NotificationCenter.default.publisher(for: .cloudKitSchemaReady)
            .sink { [weak self] _ in
                Task { @MainActor in
                    log("CloudKit schema is ready, retrying failed messages", category: "MessageStore")
                    self?.retryFailedMessages()
                }
            }
            .store(in: &cancellables)
        
        // UserID„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„ÅØÂªÉÊ≠¢ÔºàroomID=zoneName‰∏çÂ§â„ÅÆ„Åü„ÇÅÔºâ
    }
    
    /// ÁâπÂÆö„ÅÆ„É´„Éº„É†Áî®„ÅÆPush Notification„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇíË®≠ÂÆö
    private func setupRoomPushNotifications() {
        Task {
            do {
                try await CloudKitChatManager.shared.setupRoomSubscription(for: roomID)
                log("‚úÖ Room subscription setup completed for: \(roomID)", category: "MessageStore")
            } catch {
                log("‚ùå Failed to setup room subscription: \(error)", category: "MessageStore")
            }
        }
    }
    
    private func loadInitialMessages() {
        isLoading = true
        
        // Load messages from local SwiftData
        do {
            let descriptor = FetchDescriptor<Message>()
            let allMessages = try modelContext.fetch(descriptor)
            let currentRoomID = self.roomID
            let filteredMessages = allMessages.filter { message in
                return message.roomID == currentRoomID
            }
            messages = filteredMessages.sorted { $0.createdAt < $1.createdAt }
            log("Loaded \(messages.count) messages from local storage", category: "MessageStore")
        } catch {
            log("Failed to load messages: \(error)", category: "MessageStore")
        }
        
        isLoading = false
        
        // Trigger sync check
        if #available(iOS 17.0, *) {
            MessageSyncPipeline.shared.checkForUpdates(roomID: roomID)
        }
    }
    
    // MARK: - Message Operations
    
func sendMessage(_ text: String) {
        guard let senderID = CloudKitChatManager.shared.currentUserID else {
            log("‚ùå Cannot send: currentUserID not available", category: "MessageStore")
            return
        }
        let message = Message(
            roomID: roomID,
            senderID: senderID,
            body: text,
            createdAt: Date(),
            isSent: false
        )
        
        // ËøΩË∑°Áî®„ÅÆ‰∏ÄÊôÇ„Éá„Éê„ÉÉ„Ç∞„ÅØÂâäÈô§ÔºàÊñπÈáùÊ∫ñÊã†Ôºâ
        
        // Optimistic UI update with batch processing
        _ = message.generateRecordName()
        
        // Batch UI update
        withAnimation(.easeInOut(duration: 0.2)) {
            messages.append(message)
        }
        
        modelContext.insert(message)
        
        // Save to persistent storage
        do {
            try modelContext.save()
            log("Message saved locally: \(message.id)", category: "MessageStore")
            // ‰∏ÄÊôÇ„Éá„Éê„ÉÉ„Ç∞„É≠„ÇÆ„É≥„Ç∞„ÇíÊí§Âéª
        } catch {
            // Remove from UI if save failed
            if let index = messages.firstIndex(of: message) {
                _ = withAnimation {
                    messages.remove(at: index)
                }
            }
            log("Failed to save message locally: \(error)", category: "MessageStore")
            return
        }
        
        // Sync to CloudKit
        syncToCloudKit(message)
    }
    
    func sendImageMessage(_ image: UIImage) {
        guard let senderID = CloudKitChatManager.shared.currentUserID else {
            log("‚ùå Cannot send image: currentUserID not available", category: "MessageStore")
            return
        }
        guard let localURL = AttachmentManager.saveImageToCache(image) else {
            log("Failed to save image to cache", category: "MessageStore")
            return
        }

        let message = Message(
            roomID: roomID,
            senderID: senderID,
            body: nil,
            assetPath: localURL.path,
            createdAt: Date(),
            isSent: false
        )
        // Ê•ΩË¶≥ÁöÑUIÂèçÊò† + „É≠„Éº„Ç´„É´‰øùÂ≠òÔºà„ÉÜ„Ç≠„Çπ„Éà„Å®Êï¥ÂêàÔºâ
        _ = message.generateRecordName()
        withAnimation(.easeInOut(duration: 0.2)) {
            messages.append(message)
            messages.sort { $0.createdAt < $1.createdAt }
        }
        modelContext.insert(message)
        do {
            try modelContext.save()
            log("Message(image) saved locally: id=\(message.id)", category: "MessageStore")
        } catch {
            if let idx = messages.firstIndex(of: message) { _ = withAnimation { messages.remove(at: idx) } }
            log("Failed to save image message locally: \(error)", category: "MessageStore")
            return
        }
        // ÂêåÊúü„Ç≠„É•„Éº„Å∏ÁôªÈå≤
        syncToCloudKit(message)
    }
    
    func sendVideoMessage(_ videoURL: URL) {
        guard let senderID = CloudKitChatManager.shared.currentUserID else {
            log("‚ùå Cannot send video: currentUserID not available", category: "MessageStore")
            return
        }
        // Copy to permanent storage
        let permanentURL = AttachmentManager.makeFileURL(ext: videoURL.pathExtension)

        do {
            try FileManager.default.copyItem(at: videoURL, to: permanentURL)
        } catch {
            log("Failed to copy video to permanent storage: \(error)", category: "MessageStore")
            return
        }

        let message = Message(
            roomID: roomID,
            senderID: senderID,
            body: nil,
            assetPath: permanentURL.path,
            createdAt: Date(),
            isSent: false
        )
        // Ê•ΩË¶≥ÁöÑUIÂèçÊò† + „É≠„Éº„Ç´„É´‰øùÂ≠òÔºà„ÉÜ„Ç≠„Çπ„Éà„Å®Êï¥ÂêàÔºâ
        _ = message.generateRecordName()
        withAnimation(.easeInOut(duration: 0.2)) {
            messages.append(message)
            messages.sort { $0.createdAt < $1.createdAt }
        }
        modelContext.insert(message)
        do {
            try modelContext.save()
            log("Message(video) saved locally: id=\(message.id)", category: "MessageStore")
        } catch {
            if let idx = messages.firstIndex(of: message) { _ = withAnimation { messages.remove(at: idx) } }
            log("Failed to save video message locally: \(error)", category: "MessageStore")
            return
        }
        // ÂêåÊúü„Ç≠„É•„Éº„Å∏ÁôªÈå≤
        syncToCloudKit(message)
    }
    
    func updateMessage(_ message: Message, newBody: String) {
        let oldBody = message.body
        message.body = newBody
        message.isSent = false
        let recNameInfo = message.ckRecordName ?? "nil"
        log("‚úèÔ∏è [UI UPDATE] commit start id=\(message.id) record=\(recNameInfo) room=\(message.roomID) newLen=\(newBody.count)", category: "MessageStore")
        
        // Save to persistent storage
        do {
            try modelContext.save()
            log("‚úèÔ∏è [UI UPDATE] local saved id=\(message.id) record=\(recNameInfo)", category: "MessageStore")
        } catch {
            // Revert on failure
            message.body = oldBody
            log("‚ùå [UI UPDATE] local save failed id=\(message.id) record=\(recNameInfo) error=\(error)", category: "MessageStore")
            return
        }
        
        // Sync via CKSyncEngine (WorkItem)
        Task { @MainActor in
            if #available(iOS 17.0, *) {
                if let recordName = message.ckRecordName {
                    await CKSyncEngineManager.shared.queueUpdateMessage(
                        recordName: recordName,
                        roomID: message.roomID,
                        newBody: newBody,
                        newTimestamp: Date()
                    )
                    message.isSent = true
                    log("‚úèÔ∏è [UI UPDATE] queued to Engine id=\(message.id) record=\(recNameInfo)", category: "MessageStore")
                }
            } else {
                
                log("‚ö†Ô∏è [UI UPDATE] CKSyncEngine not available on this OS version", category: "MessageStore")
                
            }
        }
    }
    
    func deleteMessage(_ message: Message) {
        let recNameInfo = message.ckRecordName ?? "nil"
        log("üóëÔ∏è [UI DELETE] request id=\(message.id) record=\(recNameInfo) room=\(message.roomID) hasAsset=\(message.assetPath != nil)", category: "MessageStore")
        // Remove from UI with animation
        if let index = messages.firstIndex(of: message) {
            _ = withAnimation(.easeInOut(duration: 0.2)) {
                messages.remove(at: index)
            }
        }
        
        // Remove from persistent storage
        modelContext.delete(message)
        
        do {
            try modelContext.save()
            log("üóëÔ∏è [UI DELETE] local removed id=\(message.id) record=\(recNameInfo)", category: "MessageStore")
        } catch {
            log("‚ùå [UI DELETE] local delete failed id=\(message.id) record=\(recNameInfo) error=\(error)", category: "MessageStore")
            // Re-add to UI if delete failed
            withAnimation {
                messages.append(message)
                messages.sort { $0.createdAt < $1.createdAt }
            }
            return
        }
        
        // Sync deletion via CKSyncEngine (WorkItem)
        if let recordName = message.ckRecordName, #available(iOS 17.0, *) {
            Task { @MainActor in
                await CKSyncEngineManager.shared.queueDeleteMessage(recordName: recordName, roomID: message.roomID)
                log("üóëÔ∏è [UI DELETE] queued to Engine record=\(recordName)", category: "MessageStore")
            }
        }
    }
    
    /// „É°„ÉÉ„Çª„Éº„Ç∏„Å´„É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÁµµÊñáÂ≠ó„ÇíËøΩÂä†ÔºàCloudKitÊ≠£Ë¶èÂåñ„É¨„Ç≥„Éº„Éâ„Å´‰∏ÄÊú¨ÂåñÔºâ
    func addReaction(_ emoji: String, to message: Message) {
        log("Reaction enqueue only (CloudKit): \(emoji) to id=\(message.id)", category: "MessageStore")
        
        guard let recordName = message.ckRecordName else {
            log("Cannot sync reaction: message has no CloudKit record name", category: "MessageStore")
            return
        }
        
        Task { @MainActor in
            if #available(iOS 17.0, *) {
                if let userID = CloudKitChatManager.shared.currentUserID {
                    await CKSyncEngineManager.shared.queueReaction(
                        messageRecordName: recordName,
                        roomID: message.roomID,
                        emoji: emoji,
                        userID: userID
                    )
                    message.isSent = true
                    log("Reaction enqueued to CKSyncEngine: \(emoji)", category: "MessageStore")
                }
            } else {
                let error = NSError(
                    domain: "MessageStore",
                    code: -1001,
                    userInfo: [NSLocalizedDescriptionKey: "iOS 17 or later is required for CloudKit reaction sync"]
                )
                syncError = error
                log("‚ùå Reaction sync requires iOS 17+: \(error.localizedDescription)", category: "MessageStore")
            }
        }
    }
    
    // MARK: - Private Helpers
    
    private func refreshReactions(for messageRecordName: String) {
        let currentRoomID = self.roomID
        guard messages.contains(where: { $0.ckRecordName == messageRecordName }) else { return }
        Task { @MainActor in
            do {
                let list = try await CloudKitChatManager.shared.getReactionsForMessage(
                    messageRecordName: messageRecordName,
                    roomID: currentRoomID
                )
                if !list.isEmpty {
                    log("Reactions fetched (count=\(list.count)) for message: \(messageRecordName)", category: "MessageStore")
                }
                NotificationCenter.default.post(
                    name: .reactionsUpdated,
                    object: nil,
                    userInfo: ["recordName": messageRecordName]
                )
            } catch {
                log("Failed to refresh reactions for message: \(messageRecordName) - \(error)", category: "MessageStore")
            }
        }
    }
    /*
            log("üéØ ENQUEUE TRACKED MESSAGE (ENGINE): '\(body)' - Message ID: \(message.id)", category: "MessageStore")
        }

        // Engine„Å∏ÂÆåÂÖ®ÁßªË°åÔºöWorkItemÂåñ„Åó„Å¶ÈÄÅ‰ø°„ÇíÂßîË≠≤
        Task { @MainActor in
            if #available(iOS 17.0, *) {
                await CKSyncEngineManager.shared.queueMessage(message)
                if let path = message.assetPath {
                    await CKSyncEngineManager.shared.queueAttachment(
                        messageRecordName: message.id.uuidString,
                        roomID: message.roomID,
                        localFileURL: URL(fileURLWithPath: path)
                    )
                }
                log("üìÆ Queued message to CKSyncEngine: id=\(message.id)", category: "MessageStore")
            } else {
                log("‚ö†Ô∏è CKSyncEngine not available on this OS version", category: "MessageStore")
            }
        }
    }
    
*/
    private func syncToCloudKit(_ message: Message) {
        guard message.isValidForSync else {
            log("Message is not valid for sync: \(message.id)", category: "MessageStore")
            return
        }
        // ‰∏ÄÊôÇ„Éá„Éê„ÉÉ„Ç∞„É≠„ÇÆ„É≥„Ç∞„ÇíÊí§Âéª
        Task { @MainActor in
            if #available(iOS 17.0, *) {
                await CKSyncEngineManager.shared.queueMessage(message)
                if let path = message.assetPath {
                    await CKSyncEngineManager.shared.queueAttachment(
                        messageRecordName: message.id.uuidString,
                        roomID: message.roomID,
                        localFileURL: URL(fileURLWithPath: path)
                    )
                }
                log("Queued message to CKSyncEngine: id=\(message.id)", category: "MessageStore")
            } else {
                log("CKSyncEngine not available on this OS version", category: "MessageStore")
            }
        }
    }

    private func handleReceivedMessage(_ message: Message) {
        // Âèó‰ø°Âá¶ÁêÜ„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ„ÅØË°å„ÅÜ„Åå„ÄÅ„É≠„Ç∞„ÅØÊúÄÂ∞èÈôê
        
        // ÊîπÂñÑ„Åï„Çå„ÅüÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÔºö„Çà„ÇäÂé≥ÂØÜ„Å´„ÉÅ„Çß„ÉÉ„ÇØ„Åó„ÄÅ„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÇíËøΩÂä†
        if let targetRecordName = message.ckRecordName {
            // 1. „É°„É¢„É™ÂÜÖ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàÂêå‰∏Ä„É¨„Ç≥„Éº„ÉâÂêç„ÅßÂêå‰∏ÄÈÄÅ‰ø°ËÄÖ„ÅÆ„ÅøÔºâ
            let existingInMemory = messages.first(where: { 
                $0.ckRecordName == targetRecordName && $0.senderID == message.senderID 
            })
            if let existing = existingInMemory {
                // Êó¢Â≠òUIÊõ¥Êñ∞ÔºàÈÄÅÈÅîÁ¢∫ÂÆö„Éª„É™„Ç¢„ÇØ„Ç∑„Éß„É≥Â∑ÆÂàÜ„ÉªÊ∑ª‰ªòÂèçÊò†Ôºâ
                existing.isSent = true
                // reactionEmoji „ÅØÂªÉÊ≠¢ÔºàCloudKitÊ≠£Ë¶èÂåñ„Å´Áµ±‰∏ÄÔºâ
                if let newPath = message.assetPath, existing.assetPath != newPath {
                    existing.assetPath = newPath
                }
                // Ê∑ª‰ªò„ÅåÂÖàË°å„Åó„Å¶„ÅÑ„ÅüÂ†¥Âêà„ÅÆÈÅ©Áî®
                if let queuedPath = pendingAttachmentPaths[targetRecordName] {
                    if existing.assetPath != queuedPath {
                        existing.assetPath = queuedPath
                        do { try modelContext.save() } catch { log("Failed to save queued attachment path: \(error)", category: "MessageStore") }
                    }
                    pendingAttachmentPaths.removeValue(forKey: targetRecordName)
                }
                log("[DEDUP] In-memory matched ck=\(String(targetRecordName.prefix(8))) sender=\(String(message.senderID.prefix(8)))", category: "MessageStore")
                return
            }
            
            // Áï∞„Å™„ÇãÈÄÅ‰ø°ËÄÖ„ÅÆÂêå‰∏Ä„É¨„Ç≥„Éº„ÉâÂêç„ÅØÂá¶ÁêÜ„ÇíÁ∂öË°å
            let sameRecordDifferentSender = messages.first(where: { 
                $0.ckRecordName == targetRecordName && $0.senderID != message.senderID 
            })
            _ = sameRecordDifferentSender
            
            // 2. „É≠„Éº„Ç´„É´„Éá„Éº„Çø„Éô„Éº„Çπ„ÇÇ„ÉÅ„Çß„ÉÉ„ÇØÔºàÂêå‰∏ÄÈÄÅ‰ø°ËÄÖ„ÅÆÈáçË§á„ÅÆ„ÅøÔºâ
            do {
                let currentSenderID = message.senderID
                let descriptor = FetchDescriptor<Message>(
                    predicate: #Predicate<Message> { msg in 
                        msg.ckRecordName == targetRecordName && msg.senderID == currentSenderID
                    }
                )
                let existingMessages = try modelContext.fetch(descriptor)
                if !existingMessages.isEmpty {
                    let existing = existingMessages.first!
                    existing.isSent = true
                    // UI„Å´„Åæ„Å†ÁÑ°„Åë„Çå„Å∞ËøΩÂä†
                    let inUI = messages.contains { $0.ckRecordName == targetRecordName && $0.senderID == currentSenderID }
                    if !inUI {
                        withAnimation(.easeInOut(duration: 0.2)) {
                            messages.append(existing)
                            messages.sort { $0.createdAt < $1.createdAt }
                        }
                        log("[DEDUP] DB matched and appended ck=\(String(targetRecordName.prefix(8)))", category: "MessageStore")
                    }
                    // Ê∑ª‰ªò„ÅåÂÖàË°å„Åó„Å¶„ÅÑ„ÅüÂ†¥Âêà„ÅÆÈÅ©Áî®
                    if let queuedPath = pendingAttachmentPaths[targetRecordName] {
                        if existing.assetPath != queuedPath {
                            existing.assetPath = queuedPath
                            do { try modelContext.save() } catch { log("Failed to save queued attachment path: \(error)", category: "MessageStore") }
                        }
                        pendingAttachmentPaths.removeValue(forKey: targetRecordName)
                    }
                    log("[DEDUP] DB matched ck=\(String(targetRecordName.prefix(8))) sender=\(String(currentSenderID.prefix(8)))", category: "MessageStore")
                    return
                }
                
                // Áï∞„Å™„ÇãÈÄÅ‰ø°ËÄÖ„ÅÆÂêå‰∏Ä„É¨„Ç≥„Éº„ÉâÂêç„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàÊÉÖÂ†±„É≠„Ç∞„ÅÆ„ÅøÔºâ
                let differentSenderDescriptor = FetchDescriptor<Message>(
                    predicate: #Predicate<Message> { msg in 
                        msg.ckRecordName == targetRecordName && msg.senderID != currentSenderID
                    }
                )
                let differentSenderMessages = try modelContext.fetch(differentSenderDescriptor)
                _ = differentSenderMessages
            } catch {
                // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅØÂá¶ÁêÜ„ÇíÁ∂öË°å
            }
            
            // ÈáçË§á„Å™„Åó
        } else {
            // ckRecordName„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ‰ªñ„ÅÆÊù°‰ª∂„ÅßÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
            let possibleDuplicate = messages.first { existing in
                existing.senderID == message.senderID &&
                existing.body == message.body &&
                abs(existing.createdAt.timeIntervalSince(message.createdAt)) < 60 // 60Áßí‰ª•ÂÜÖ„Å´Êã°Â§ß
            }
            
            if let duplicate = possibleDuplicate {
                _ = duplicate
                log("[DEDUP] Heuristic duplicate (no ck) sender=\(String(message.senderID.prefix(8))) body=\(String((message.body ?? "").prefix(10)))", category: "MessageStore")
                return
            }
        }
        
        // „Ç∑„Çπ„ÉÜ„É†„É°„ÉÉ„Çª„Éº„Ç∏ÔºàFaceTimeÁôªÈå≤Ôºâ„ÅÆÂ†¥Âêà„ÅØ„É≠„Éº„Ç´„É´„Å´Áõ∏Êâã„ÅÆFaceTimeID„Çí‰øùÂ≠ò
        if let sysID = Message.extractFaceTimeID(from: message.body) {
            var dict = (UserDefaults.standard.dictionary(forKey: "FaceTimeIDs") as? [String: String]) ?? [:]
            dict[message.senderID] = sysID
            UserDefaults.standard.set(dict, forKey: "FaceTimeIDs")
            log("üìû [SYS] Stored FaceTimeID for sender=\(String(message.senderID.prefix(8)))", category: "MessageStore")
        }

        // roomID„ÉÅ„Çß„ÉÉ„ÇØ
        if message.roomID != self.roomID {
            return
        }
        
        // Add to local storage
        modelContext.insert(message)
        
        do {
            try modelContext.save()
            
            // Update UI with animation
            withAnimation(.easeInOut(duration: 0.2)) {
                messages.append(message)
                messages.sort { $0.createdAt < $1.createdAt }
            }
            
            // Ê∑ª‰ªò„ÅåÂÖà„Å´Âà∞ÁùÄ„Åó„Å¶„ÅÑ„ÅüÂ†¥Âêà„ÅØ„Åì„Åì„ÅßÈÅ©Áî®
            if let rnFull = message.ckRecordName, let queuedPath = pendingAttachmentPaths[rnFull] {
                if message.assetPath != queuedPath {
                    message.assetPath = queuedPath
                    pendingAttachmentPaths.removeValue(forKey: rnFull)
                    do { try modelContext.save() } catch { log("Failed to save queued attachment path: \(error)", category: "MessageStore") }
                }
            }
            
            let rn = message.ckRecordName.map { String($0.prefix(8)) } ?? "nil"
            log("‚úÖ Message received: id=\(message.id) sender=\(String(message.senderID.prefix(8))) record=\(rn)", category: "MessageStore")
        
        } catch {
            log("‚ùå Failed to save received message: \(error)", category: "MessageStore")
        }
    }
    
    private func handleDeletedMessage(_ recordName: String) {
        // Find and remove message
        if let index = messages.firstIndex(where: { $0.ckRecordName == recordName }) {
            let message = messages[index]
            messages.remove(at: index)
            modelContext.delete(message)
            
            do {
                try modelContext.save()
                log("Deleted message: \(recordName)", category: "MessageStore")
            } catch {
                log("Failed to delete message: \(error)", category: "MessageStore")
            }
        }
    }
    
    // MARK: - Public Utilities
    
    func refresh() {
        log("Manual refresh requested for roomID: \(roomID)", category: "MessageStore")
        
        if #available(iOS 17.0, *) {
            MessageSyncPipeline.shared.checkForUpdates(roomID: roomID)
        } else {
            // Manual refresh for legacy implementation
            loadInitialMessages()
        }
        
        // ‰ΩôË®à„Å™ÂÖ®‰ª∂„ÉÄ„É≥„Éó„ÅØË°å„Çè„Åö„ÄÅÂøÖË¶ÅÊúÄÂ∞èÈôê„ÅÆÂ∑ÆÂàÜÁ¢∫Ë™ç„ÅÆ„ÅøÂÆüÊñΩ
        Task { @MainActor in
            do {
                let descriptor = FetchDescriptor<Message>()
                let allMessages = try modelContext.fetch(descriptor)
                let currentRoomMessages = allMessages.filter { $0.roomID == self.roomID }
                let sortedMessages = currentRoomMessages.sorted { $0.createdAt < $1.createdAt }
                
                // ÈÄÅ‰ø°ËÄÖÂà•„Çµ„Éû„É™„ÇíÁü≠„ÅèÂá∫ÂäõÔºàUIÊ§úË®º„Åó„ÇÑ„Åô„ÅèÈõÜÁ¥ÑÔºâ
                let myID = CloudKitChatManager.shared.currentUserID ?? "unknown"
                let mineCount = sortedMessages.filter { $0.senderID == myID }.count
                let otherCount = sortedMessages.count - mineCount
                log("Local DB: total=\(sortedMessages.count) room=\(roomID) mine=\(mineCount) other=\(otherCount)", category: "MessageStore")
                log("UI shows \(messages.count) messages", category: "MessageStore")
                
                // ‰ª∂Êï∞/ÂÜÖÂÆπÂ∑ÆÂàÜ„Å´Âøú„Åò„Å¶UIÊúÄÂ∞èÊõ¥Êñ∞
                if sortedMessages.count != messages.count {
                    log("Message count mismatch detected. Reloading UI...", category: "MessageStore")
                    log("Before UI update: messages.count = \(messages.count), sortedMessages.count = \(sortedMessages.count)", category: "MessageStore")
                    
                    self.messages.removeAll()
                    DispatchQueue.main.async {
                        withAnimation(.easeInOut(duration: 0.3)) {
                            self.messages = sortedMessages
                        }
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                            log("After UI update: messages.count = \(self.messages.count)", category: "MessageStore")
                            if self.messages.count != sortedMessages.count {
                                self.messages = sortedMessages
                            }
                        }
                    }
                } else {
                    // ÂêåÊï∞„Åß„ÇÇÊú¨ÊñáÂ∑ÆÂàÜ„Åå„ÅÇ„Çå„Å∞ÊúÄÂ∞èÊõ¥Êñ∞
                    let uiMessageBodies = Set(messages.compactMap(\.body))
                    let dbMessageBodies = Set(sortedMessages.compactMap(\.body))
                    if uiMessageBodies != dbMessageBodies {
                        log("Message content mismatch detected despite same count. Reloading UI...", category: "MessageStore")
                        withAnimation(.easeInOut(duration: 0.3)) {
                            self.messages = sortedMessages
                        }
                    }
                }
            } catch {
                log("Failed to refresh from local DB: \(error)", category: "MessageStore")
            }
        }
    }
    
    func retryFailedMessages() {
        let failedMessages = messages.filter { !$0.isSent }
        
        for message in failedMessages {
            log("Retrying failed message: \(message.id)", category: "MessageStore")
            syncToCloudKit(message)
        }
    }
    
    func getMessageCount() -> Int {
        return messages.count
    }
    
    func getUnsentMessageCount() -> Int {
        return messages.filter { !$0.isSent }.count
    }
    
    // MARK: - Offline Event Handlers
    
    private func handleNetworkRestored() {
        log("Network restored for room: \(roomID)", category: "MessageStore")
        
        // Refresh to get latest messages
        if #available(iOS 17.0, *) {
            MessageSyncPipeline.shared.checkForUpdates(roomID: roomID)
        }
        
        // Retry failed messages
        retryFailedMessages()
    }
    
    private func handleNetworkLost() {
        log("Network lost for room: \(roomID)", category: "MessageStore")
        // No immediate action needed - messages will be queued automatically
    }
    
    private func handleMessageFailedPermanently(_ message: Message) {
        log("Message failed permanently: \(message.id)", category: "MessageStore")
        
        // Mark message as failed in UI
        message.isSent = false
        objectWillChange.send()
        
        // Show error state
        syncError = MessageStoreError.messageFailed(message.id.uuidString)
    }
    
    // „É¶„Éº„Ç∂„ÉºID„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥/‰∏ÄÊôÇIDÊõ¥Êñ∞„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ„ÅØÂªÉÊ≠¢ÔºàroomID=zoneName „Çí‰∏çÂ§â„Å®„Åô„ÇãÔºâ
    
    // MARK: - Debug Functions
    
    /// „Éá„Éê„ÉÉ„Ç∞Áî®Ôºö„Éá„Éº„Çø„Éô„Éº„ÇπÂÖ®‰Ωì„ÅÆÁä∂ÊÖã„ÇíÂá∫Âäõ
    func debugPrintEntireDatabase() {
        Task { @MainActor in
            do {
                let descriptor = FetchDescriptor<Message>()
                let allMessages = try modelContext.fetch(descriptor)
                
                log("==================================================", category: "App")
                log("üîç DEBUG: ENTIRE DATABASE CONTENTS", category: "MessageStore")
                log("üîç Total messages in DB: \(allMessages.count)", category: "MessageStore")
                log("==================================================", category: "App")
                
                let sortedMessages = allMessages.sorted { $0.createdAt < $1.createdAt }
                
                for (index, msg) in sortedMessages.enumerated() {
                    let body = msg.body ?? "nil"
                    let senderID = msg.senderID.isEmpty ? "empty" : msg.senderID
                    let roomID = msg.roomID.isEmpty ? "empty" : msg.roomID  // ÂÆåÂÖ®„Å™Room ID„Åß„Éá„Éê„ÉÉ„Ç∞
                    let recordName = msg.ckRecordName ?? "nil"
                    let isSent = msg.isSent ? "‚úÖ" : "‚ùå"
                    
                    log("üîç [\(String(format: "%02d", index))] \(isSent) '\(body)' | Room:\(roomID) | Sender:\(String(senderID.prefix(8))) | Record:\(String(recordName.prefix(8))) | \(msg.createdAt)", category: "MessageStore")
                    
                    // ‰∏ÄÊôÇ„Éá„Éê„ÉÉ„Ç∞„É≠„ÇÆ„É≥„Ç∞„ÇíÊí§Âéª
                }
                
                log("==================================================", category: "App")
                log("üîç CURRENT ROOM: \(roomID)", category: "MessageStore")
                let roomMessages = sortedMessages.filter { $0.roomID == self.roomID }
                log("üîç Messages for current room: \(roomMessages.count)", category: "MessageStore")
                log("üîç Messages in UI: \(messages.count)", category: "MessageStore")
                log("==================================================", category: "App")
                
            } catch {
                log("‚ùå Failed to debug print database: \(error)", category: "MessageStore")
            }
        }
    }
    
    /// „Éá„Éê„ÉÉ„Ç∞Áî®ÔºöÂÆöÊúüÁöÑ„Å´DBÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    func startPeriodicDatabaseCheck() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            Task { @MainActor in
                log("üïê Periodic DB check...", category: "MessageStore")
                self.debugPrintEntireDatabase()
            }
        }
    }
    
    /// „Éá„Éê„ÉÉ„Ç∞Áî®ÔºöÁâπÂÆö„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíDBÂÖ®‰Ωì„Åã„ÇâÊ§úÁ¥¢
    func debugSearchForMessage(containing text: String) {
        Task { @MainActor in
            do {
                let descriptor = FetchDescriptor<Message>()
                let allMessages = try modelContext.fetch(descriptor)
                let matchingMessages = allMessages.filter { message in
                    if let body = message.body {
                        return body.contains(text)
                    }
                    return false
                }
                
                log("==================================================", category: "App")
                log("üîç DEBUG SEARCH for '\(text)'", category: "MessageStore")
                log("üîç Found \(matchingMessages.count) matching messages", category: "MessageStore")
                log("==================================================", category: "App")
                
                for (index, msg) in matchingMessages.enumerated() {
                    log("üîç [\(index)] '\(msg.body ?? "nil")' | Room: \(String(msg.roomID.prefix(8))) | Sender: \(String(msg.senderID.prefix(8))) | \(msg.createdAt) | Record: \(msg.ckRecordName ?? "nil")", category: "MessageStore")
                }
                
                log("==================================================", category: "App")
                
            } catch {
                log("‚ùå Failed to search database: \(error)", category: "MessageStore")
            }
        }
    }
    
    // MARK: - Enhanced Utilities
    
    func getOfflineStatistics() async -> OfflineStatistics {
        let unsentCount = getUnsentMessageCount()
        var queued = 0
        if #available(iOS 17.0, *) {
            let stats = await CKSyncEngineManager.shared.pendingStats()
            queued = stats.total
        }
        return OfflineStatistics(
            isOnline: offlineManager.isOnline,
            queuedMessages: queued,
            failedMessages: 0,
            unsentMessages: unsentCount,
            lastSyncDate: offlineManager.lastSyncDate
        )
    }
    
    func forceSync() async {
        if #available(iOS 17.0, *) {
            await CKSyncEngineManager.shared.kickSyncNow()
        } else {
            log("‚ö†Ô∏è forceSync no-op (CKSyncEngine unavailable)", category: "MessageStore")
        }
    }
    
    func clearOfflineQueue() {
        if #available(iOS 17.0, *) {
            Task { await CKSyncEngineManager.shared.resetEngines() }
        } else {
            log("‚ö†Ô∏è clearOfflineQueue no-op (CKSyncEngine unavailable)", category: "MessageStore")
        }
    }
    
    // MARK: - Debug Functions
    
    /// „Éá„Éê„ÉÉ„Ç∞Áî®ÔºöDBÂÖ®‰Ωì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
    func debugPrintAllMessages() {
        Task { @MainActor in
            do {
                let descriptor = FetchDescriptor<Message>()
                let allMessages = try modelContext.fetch(descriptor)
                
                log("\n" + String(repeating: "=", count: 80), category: "App")
                log("üìä ENTIRE DATABASE CONTENTS (\(allMessages.count) messages)", category: "DEBUG")
                log(String(repeating: "=", count: 80), category: "App")
                
                let sortedMessages = allMessages.sorted { $0.createdAt < $1.createdAt }
                
                for (index, msg) in sortedMessages.enumerated() {
                    let body = msg.body ?? "nil"
                    let senderInfo = msg.senderID.isEmpty ? "unknown" : msg.senderID
                    let roomInfo = msg.roomID.isEmpty ? "unknown" : String(msg.roomID.prefix(8))
                    let recordInfo = msg.ckRecordName ?? "nil"
                    
                    log("[\(String(format: "%03d", index))] üìù", category: "DEBUG")
                    log("    üìç Room: \(roomInfo)...", category: "App")
                    log("    üë§ Sender: \(senderInfo)", category: "App")
                    log("    üí¨ Body: '\(body)'", category: "App")
                    log("    üìÖ Created: \(msg.createdAt)", category: "App")
                    log("    üÜî Record: \(recordInfo)", category: "App")
                    log("    ‚úÖ Sent: \(msg.isSent)", category: "App")
                    log("", category: "App")
                }
                
                log(String(repeating: "=", count: 80), category: "App")
                log("END OF DATABASE DUMP", category: "DEBUG")
                log(String(repeating: "=", count: 80) + "\n", category: "App")
                
            } catch {
                log("‚ùå Failed to fetch all messages: \(error)", category: "DEBUG")
            }
        }
    }
    
    /// „Éá„Éê„ÉÉ„Ç∞Áî®ÔºöÁâπÂÆö„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„ÅßDBÂÖ®‰Ωì„ÇíÊ§úÁ¥¢
    func debugSearchMessages(_ keyword: String) {
        Task { @MainActor in
            do {
                let descriptor = FetchDescriptor<Message>()
                let allMessages = try modelContext.fetch(descriptor)
                
                let matchingMessages = allMessages.filter { message in
                    if let body = message.body {
                        return body.contains(keyword)
                    }
                    return false
                }
                
                log("\n" + String(repeating: "=", count: 80), category: "App")
                log("üîç SEARCH RESULTS for '\(keyword)' (\(matchingMessages.count) matches)", category: "DEBUG")
                log(String(repeating: "=", count: 80), category: "App")
                
                if matchingMessages.isEmpty {
                    log("üö´ No messages found containing '\(keyword)'", category: "DEBUG")
                } else {
                    let sortedMatches = matchingMessages.sorted { $0.createdAt < $1.createdAt }
                    
                    for (index, msg) in sortedMatches.enumerated() {
                        let body = msg.body ?? "nil"
                        let senderInfo = msg.senderID.isEmpty ? "unknown" : msg.senderID
                        let roomInfo = msg.roomID.isEmpty ? "unknown" : String(msg.roomID.prefix(8))
                        let recordInfo = msg.ckRecordName ?? "nil"
                        
                        log("MATCH [\(index + 1)] üéØ", category: "DEBUG")
                        log("    üìç Room: \(roomInfo)...", category: "App")
                        log("    üë§ Sender: \(senderInfo)", category: "App")
                        log("    üí¨ Body: '\(body)'", category: "App")
                        log("    üìÖ Created: \(msg.createdAt)", category: "App")
                        log("    üÜî Record: \(recordInfo)", category: "App")
                        log("    ‚úÖ Sent: \(msg.isSent)", category: "App")
                        log("", category: "App")
                    }
                }
                
                log(String(repeating: "=", count: 80), category: "App")
                log("END OF SEARCH RESULTS", category: "DEBUG")
                log(String(repeating: "=", count: 80) + "\n", category: "App")
                
            } catch {
                log("‚ùå Failed to search messages: \(error)", category: "DEBUG")
            }
        }
    }
    
    /// „Éá„Éê„ÉÉ„Ç∞Áî®ÔºöÁèæÂú®„ÅÆ„É´„Éº„É†„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Å®ÂÖ®‰Ωì„ÅÆÊØîËºÉ
    func debugCompareRoomMessages() {
        Task { @MainActor in
            do {
                let descriptor = FetchDescriptor<Message>()
                let allMessages = try modelContext.fetch(descriptor)
                let currentRoomMessages = allMessages.filter { $0.roomID == self.roomID }
                
                log("\n" + String(repeating: "=", count: 80), category: "App")
                log("üìä ROOM MESSAGE COMPARISON", category: "DEBUG")
                log(String(repeating: "=", count: 80), category: "App")
                log("üè† Current Room ID: \(roomID)", category: "DEBUG")
                log("üì± UI Messages: \(messages.count)", category: "DEBUG")
                log("üóÑÔ∏è DB Room Messages: \(currentRoomMessages.count)", category: "DEBUG")
                log("üåç Total DB Messages: \(allMessages.count)", category: "DEBUG")
                log("", category: "App")
                
                // UI „Å®DB„ÅÆÈÅï„ÅÑ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                let uiMessageIDs = Set(messages.map(\.id.uuidString))
                let dbMessageIDs = Set(currentRoomMessages.map(\.id.uuidString))
                
                let onlyInUI = uiMessageIDs.subtracting(dbMessageIDs)
                let onlyInDB = dbMessageIDs.subtracting(uiMessageIDs)
                
                if !onlyInUI.isEmpty {
                    log("‚ö†Ô∏è Messages only in UI (\(onlyInUI.count)): \(onlyInUI)", category: "DEBUG")
                }
                
                if !onlyInDB.isEmpty {
                    log("‚ö†Ô∏è Messages only in DB (\(onlyInDB.count)): \(onlyInDB)", category: "DEBUG")
                    
                    // DB„Å´„ÅÆ„Åø„ÅÇ„Çã„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆË©≥Á¥∞„ÇíË°®Á§∫
                    let dbOnlyMessages = currentRoomMessages.filter { onlyInDB.contains($0.id.uuidString) }
                    for msg in dbOnlyMessages {
                        log("üîç DB-only message: '\(msg.body ?? "nil")' (Created: \(msg.createdAt))", category: "DEBUG")
                    }
                }
                
                // Áï∞„Å™„Çã„É´„Éº„É†„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇÇË°®Á§∫
                let otherRoomMessages = allMessages.filter { $0.roomID != self.roomID }
                if !otherRoomMessages.isEmpty {
                    log("", category: "App")
                    log("üèòÔ∏è Messages in other rooms (\(otherRoomMessages.count)):", category: "DEBUG")
                    let groupedByRoom = Dictionary(grouping: otherRoomMessages) { $0.roomID }
                    for (roomID, msgs) in groupedByRoom {
                        let roomInfo = String(roomID.prefix(8))
                        log("   Room \(roomInfo)...: \(msgs.count) messages", category: "DEBUG")
                    }
                }
                
                log(String(repeating: "=", count: 80), category: "App")
                log("END OF COMPARISON", category: "DEBUG")
                log(String(repeating: "=", count: 80) + "\n", category: "App")
                
            } catch {
                log("‚ùå Failed to compare room messages: \(error)", category: "DEBUG")
            }
        }
    }
}

// MARK: - Supporting Types

enum MessageStoreError: Error, LocalizedError, Sendable {
    case messageFailed(String) // Message ID instead of Message object
    case syncTimeout
    case invalidMessage
    case migrationFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .messageFailed(let messageId):
            return "„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: \(messageId)"
        case .syncTimeout:
            return "ÂêåÊúü„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„Åü"
        case .invalidMessage:
            return "ÁÑ°Âäπ„Å™„É°„ÉÉ„Çª„Éº„Ç∏„Åß„Åô"
        case .migrationFailed(let error):
            return "„É¶„Éº„Ç∂„ÉºID„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: \(error)"
        }
    }
}

struct OfflineStatistics {
    let isOnline: Bool
    let queuedMessages: Int
    let failedMessages: Int
    let unsentMessages: Int
    let lastSyncDate: Date?
    
    var hasIssues: Bool {
        return queuedMessages > 0 || failedMessages > 0 || unsentMessages > 0
    }
}
